<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='jslet-data-Dataset-method-constructor'><span id='jslet-data-Dataset'>/**
</span></span> * @class
 * @constructor
 * 
 * Dataset is the core class in Jslet. 
 */
jslet.data.Dataset = function (datasetCfg) {
	
	var Z = this;
	Z._name = null; //Dataset name
	Z._description = null;
	Z._recordClass = jslet.global.defaultRecordClass; //Record class, used for serialized/deserialize
	Z._records = null; //Array of data records
	Z._oriRecords = null;
	Z._fields = []; //Array of jslet.data.Field
	Z._fieldsMap = {};
	
	Z._oriFields = null;
	
	Z._normalFields = []; //Array of jslet.data.Field except the fields with children.
	Z._recno = -1;
	Z._filteredRecnoArray = null;

	Z._unitConvertFactor = 1;
	Z._unitName = null;
	Z._aborted = false;

	Z._valueFollowEnabled = true;
	
	Z._status = 0; // dataset status, optional values: 0:browse;1:created;2:updated;3:deleted;
	Z._proxyFields = null;
	
	Z._fixedFilter = null;	
	Z._filter = null;
	Z._filtered = false;
	Z._innerFilter = null; //inner variable
	Z._findCondition = null;
	Z._innerFindCondition = null; //inner variable

	Z._innerFormularFields = null; //inner variable

	Z._bof = false;
	Z._eof = false;
	Z._igoreEvent = false;
	Z._logChanges = true;
	Z._auditLogEnabled = true;
	Z._validationEnabled = true;
	
	
	Z._modiObject = null;
	Z._inputtingRecord = {};
	Z._lockCount = 0;

	Z._fixedIndexFields = null;
	Z._innerFixedIndexFields = [];
	Z._indexFields = null;
	Z._innerIndexFields = [];
	Z._sortingFields = null;

	Z._convertDestFields = null;
	Z._innerConvertDestFields = null;

	Z._masterDataset = null;
	Z._masterField = null;
	Z._detailDatasetFields = null; //Array of dataset field object

	Z._linkedControls = []; //Array of DBControl except DBLabel
	Z._linkedLabels = []; //Array of DBLabel
	Z._silence = 0;
	Z._keyField = null;
	Z._codeField = null;
	Z._nameField = null;
	Z._parentField = null;
	Z._levelOrderField = null;
	Z._selectField = null;
	Z._statusField = null;
	
	Z._contextRules = null;
	Z._contextRuleEngine = null;
	Z._contextRuleEnabled = false;

	Z._dataProvider = jslet.data.DataProvider ? new jslet.data.DataProvider() : null;

	Z._queryCriteria = null; //String query parameters 
	Z._queryUrl = null; //String query URL 
	Z._submitUrl = null; //String submit URL
	Z._pageSize = 500;
	Z._pageNo = 0;  
	Z._pageCount = 0;
	//The following attributes are used for private.
	Z._ignoreFilter = false;
	Z._ignoreFilterRecno = 0;
	
	Z._fieldValidator = new jslet.data.FieldValidator();
	
	Z._onFieldChanged = null;  

	Z._onFieldFocusing = null;

	Z._isFireGlobalEvent = true;

	Z._onCheckSelectable = null;

	Z._onDataQuerying = null;
	
	Z._onDataQueried = null;
	
	Z._onDataSubmitted = null;
	
	Z._datasetListener = null;
	
	Z._datasetEventHandler = null;
	
	Z._designMode = false;
	
	Z._autoShowError = true;
	Z._autoRefreshHostDataset = false;
	Z._readOnly = false;
	Z._aggregatedValues = null;
	Z._afterScrollDebounce = jslet.debounce(Z._innerAfterScrollDebounce, 30);
	Z._calcAggregatedValueDebounce = jslet.debounce(Z.calcAggregatedValue, 100);
	Z.selection = new jslet.data.DataSelection(Z);
	Z._changeLog = new jslet.data.ChangeLog(Z);
	Z._dataTransformer = new jslet.data.DataTransformer(Z);
	Z._followedValues = null;
	Z._focusedFields = null;
	Z._canFocusFields = null;
	
	Z._lastFindingValue = null;
	Z._inContextRule = false;
	Z._aggregatedFields = null;
	Z._aggregatingCount = 0;
	
	Z.createdByFactory = false;
	Z._isEnum = false;
	this._create(datasetCfg);
};
jslet.data.Dataset.className = 'jslet.data.Dataset';

jslet.data.Dataset.prototype = {

	className: jslet.data.Dataset.className,
	
	_create: function(dsCfg) {
		var dsName = dsCfg.name, fieldConfig;
		jslet.Checker.test('createDataset#datasetName', dsName).required().isString();
		var Z = this;
		Z.name(dsName);
		Z.createdByFactory = dsCfg.createdByFactory;
		Z._isEnum = dsCfg.isEnum;
		if(Z._isEnum) {
			fieldConfig =  [{name: 'code', type: 'S', length: 20, displayWidth: 10, label: jsletlocale.EnumDataset.code},
			                {name: 'name', type: 'S', length: 100, displayWidth: 16, label: jsletlocale.EnumDataset.name}];
			Z.createFields(fieldConfig);
			Z.keyField('code');
			Z.codeField('code');
			Z.nameField('name');
			if(dsCfg.indexFields !== undefined) {
				Z.indexFields(dsCfg.indexFields);
			}
			if(dsCfg.records) {
				Z.records(dsCfg.records);
			}
			return;
		}
		fieldConfig = dsCfg.fields;
		Z.createFields(fieldConfig);
		
		function setPropValue(propName) {
			var propValue = dsCfg[propName];
			if (propValue !== undefined) {
				Z[propName](propValue);
			}
		}
		
		function setIntPropValue(propName) {
			var propValue = dsCfg[propName];
			if (propValue !== undefined) {
				Z[propName](parseInt(propValue));
			}
		}
		
		function setBooleanPropValue(propName) {
			var propValue = dsCfg[propName];
			if (propValue !== undefined) {
				if(jslet.isString(propValue)) {
					if(propValue) {
						propValue = propValue != '0' &amp;&amp; propValue != 'false';
					}
				}
				Z[propName](propValue? true: false);
			}
		}
		
		setPropValue('keyField');
		setPropValue('codeField');
		setPropValue('nameField');
		setPropValue('parentField');
		setPropValue('levelOrderField');
		setPropValue('selectField');
		setPropValue('statusField');
		
		setPropValue('recordClass');
		setPropValue('description');
		
		setPropValue('queryUrl');
		setPropValue('submitUrl');
		setIntPropValue('pageNo');
		setIntPropValue('pageSize');
		setPropValue('fixedIndexFields');
		setPropValue('indexFields');
		setPropValue('fixedFilter');
		setPropValue('filter');
		setBooleanPropValue('filtered');
		setBooleanPropValue('autoShowError');
		setBooleanPropValue('autoRefreshHostDataset');
		setBooleanPropValue('readOnly');
		setBooleanPropValue('logChanges');
		setBooleanPropValue('auditLogEnabled');
		setBooleanPropValue('isFireGlobalEvent');
		
		setPropValue('datasetListener');
		setPropValue('onFieldChange');
		setPropValue('onFieldChanged');
		setPropValue('onFieldChanging');
		setPropValue('onCheckSelectable');
		setPropValue('contextRules');
		
		if(dsCfg.records) {
			Z.records(dsCfg.records);
		}
	},
		
<span id='jslet-data-Dataset-property-name'>	/**
</span>	* @property
	* 
	* Set or get dataset's name. 
	* Dataset's name must be unique. Example:
	* 
	*     @example
	*     dsObj.name('test'); //Set property, return this.
	*     var propValue = dsObj.name(); //Get property value.
	* 
	* @param {String | undefined} name Dataset name.
	* 
	* @return {this | String} 
	*/
	name: function(name) {
		var Z = this;
		if(name === undefined) {
			return Z._name;
		}
		jslet.Checker.test('Dataset.name', name).required().isString();
		name = jslet.trim(name);
		
		var dsName = this._name;
		if (dsName) {
			jslet.data.dataModule[dsName] = null;
			jslet.data.datasetRelationManager.changeDatasetName(dsName, name);
		}
		jslet.data.dataModule[name] = this;
		this._name = name;
		return this;
	},
	
<span id='jslet-data-Dataset-property-description'>	/**
</span>	 * @property
	 * 
	 * Set or get dataset description. Dataset description is also used for dataset exporting as the default file name. 
	 * 
	 *     @example
	 *     dsObj.description('test'); //Set property, return this.
	 *     var propValue = dsObj.description(); //Get property value.
	 * 
	 * @param {String | undefined} description Dataset's description.
	 * 
	 * @return {this | String}
	 */
	description: function(description) {
		if(description === undefined) {
			return this._description || this._name;
		}
		this._description = description;
		return this;
	},
	
<span id='jslet-data-Dataset-property-recordClass'>	/**
</span>	 * @property
	 * 
	 * Set dataset's record class, recordClass is the server entity class quantified name.
	 * It's used for automated serialization at server side.
	 * 
	 *     @example
	 *     dsObj.recordClass('test'); //Set property, return this.
	 *     var propValue = dsObj.recordClass(); //Get property value.
	 *     
	 * @param {String | undefined} clazzName Server entity class name.
	 * 
	 * @return {this | String}
	 */
	recordClass: function(clazz) {
		var Z = this;
		if (clazz === undefined) {
			return Z._recordClass;
		}
		jslet.Checker.test('Dataset.recordClass', clazz).isString();
		Z._recordClass = clazz ? clazz.trim() : null;
		return this;
	},
		
<span id='jslet-data-Dataset-method-clone'>	/**
</span>	* Clone this dataset's structure and return new dataset object..
	* 
	* @param {String} newDsName New dataset's name.
	* @param {String[]} fieldNames a list of field names which will be cloned to new dataset.
	* 
	* @return {jslet.data.Dataset} Cloned dataset object
	*/
	clone: function (newDsName, fieldNames) {
		var Z = this;
		if (!newDsName) {
			newDsName = Z._name + '_clone';
		}
		var result = new jslet.data.Dataset({name: newDsName, fields: []});
		result._datasetListener = Z._datasetListener;

		result._unitConvertFactor = Z._unitConvertFactor;
		result._unitName = Z._unitName;

		result._fixedFilter = Z._fixedFilter;
		result._filter = Z._filter;
		result._filtered = Z._filtered;
		result._logChanges = Z._logChanges;
		result._fixedIndexFields = Z._fixedIndexFields;
		result._indexFields = Z._indexFields;
		
		var keyFldName = Z._keyField,
			codeFldName = Z._codeField,
			nameFldName = Z._nameField,
			parentFldName = Z._parentField,
			levelOrderField = Z._levelOrderField,
			selectFldName = Z._selectField,
			statusFldName = Z._statusField;
		if (fieldNames) {
			keyFldName = keyFldName &amp;&amp; fieldNames.indexOf(keyFldName) &gt;= 0 ? keyFldName: null;
			codeFldName = codeFldName &amp;&amp; fieldNames.indexOf(codeFldName) &gt;= 0 ? codeFldName: null;
			nameFldName = nameFldName &amp;&amp; fieldNames.indexOf(nameFldName) &gt;= 0 ? nameFldName: null;
			parentFldName = parentFldName &amp;&amp; fieldNames.indexOf(parentFldName) &gt;= 0 ? parentFldName: null;
			levelOrderField = levelOrderField &amp;&amp; fieldNames.indexOf(levelOrderField) &gt;= 0 ? levelOrderField: null;
			selectFldName = selectFldName &amp;&amp; fieldNames.indexOf(selectFldName) &gt;= 0 ? selectFldName: null;
			statusFldName = statusFldName &amp;&amp; fieldNames.indexOf(statusFldName) &gt;= 0 ? statusFldName: null;
		}
		result._keyField = keyFldName;
		result._codeField = codeFldName;
		result._nameField = nameFldName;
		result._parentField = parentFldName;
		result._levelOrderField = levelOrderField;
		result._selectField = selectFldName;
		result._statusField = statusFldName;
		
		result._contextRules = Z._contextRules;
		var fldObj, fldName;
		for(var i = 0, cnt = Z._fields.length; i &lt; cnt; i++) {
			fldObj = Z._fields[i];
			fldName = fldObj.name();
			if (fieldNames) {
				if (fieldNames.indexOf(fldName) &lt; 0) {
					continue;
				}
			}
			result.addField(fldObj.clone(fldName, result));
		}
		return result;
	},

<span id='jslet-data-Dataset-method-cloneRecord'>	/**
</span>	 * Clone one record to another
	 * 
	 * @param {Object} srcRecord source record
	 * @param {Object} destRecord destination record
	 */
	cloneRecord: function(srcRecord, destRecord) {
		var result = destRecord || {}, 
			fldName, fldObj, fldValue, newValue, 
			arrFieldObj = this.getNormalFields();

		for(var i = 0, len = arrFieldObj.length; i &lt; len; i++) {
			fldObj = arrFieldObj[i];
			fldName = fldObj.name();
			fldValue = srcRecord[fldName];
			if(fldValue === undefined) {
				continue;
			}
			if(fldValue &amp;&amp; jslet.isArray(fldValue)) {
				newValue = [];
				for(var j = 0, cnt = fldValue.length; j &lt; cnt; j++) {
					newValue.push(fldValue[j]);
				}
			} else {
				newValue = fldValue;
			}
			result[fldName] = newValue;
		}
		jslet.data.FieldValueCache.removeCache(result);
		return result;
	},
	
<span id='jslet-data-Dataset-property-readOnly'>	/**
</span>	 * @property 
	 *     
	 * Identity whether dataset is readonly or not. This porperty will override the field readOnly property.
	 * &lt;br /&gt;Default value: false.
	 * 
	 *     @example
	 *     dsObj.readOnly(true); //Set property, return this.
	 *     var propValue = dsObj.readOnly(); //Get property value.
	 * 
	 * @param {Boolean | undefined} readOnly.
	 * 
	 * @return {this | Boolean}
	 */
	readOnly: function(readOnly) {
		var Z = this;
		if (readOnly === undefined) {
			return Z._readOnly;
		}
		
		Z._readOnly = readOnly? true: false;
		var fields = Z.getNormalFields(),
			fldObj;
		for(var i = 0, len = fields.length; i &lt; len; i++) {
			fldObj = fields[i];
			fldObj._fireMetaChangedEvent('readOnly');
		}
		return this;
	},
	
<span id='jslet-data-Dataset-property-pageSize'>	/**
</span>	 * @property 
	 * 
	 * Set or get page size. To query paging data, you must set this property.
	 * &lt;br /&gt;Default value: 0. 
	 * 
	 *     @example
	 *     dsObj.pageSize(true); //Set property, return this.
	 *     var propValue = dsObj.pageSize(); //Get property value.
	 * 
	 * @param {Integer | undefined} pageSize Page size.
	 * 
	 * @return {this | Integer}
	 */
	pageSize: function(pageSize) {
		if (pageSize === undefined) {
			return this._pageSize;
		}
		
		jslet.Checker.test('Dataset.pageSize#pageSize', pageSize).isGTEZero();
		this._pageSize = pageSize;
		return this;
	},

<span id='jslet-data-Dataset-property-pageNo'>	/**
</span>	 * @property 
	 * 
	 * Set or get page number. To query paging data, you must set this property.
	 * &lt;br /&gt;Default value: 0. 
	 * 
	 *     @example
	 *     dsObj.pageNo(true); //Set property, return this.
	 *     var propValue = dsObj.pageNo(); //Get property value.
	 * 
	 * @param {Integer | undefined} pageNo Page number.
	 * 
	 * @return {this | Integer}
	 */
	pageNo: function(pageNo) {
		if (pageNo === undefined) {
			return this._pageNo;
		}
		
		jslet.Checker.test('Dataset.pageNo#pageNo', pageNo).isGTEZero();
		this._pageNo = pageNo;
		return this;
	},
	
<span id='jslet-data-Dataset-method-pageCount'>	/**
</span>	 * Get page count, it's a read only property.
	 * 
	 *     @example
	 *     var propValue = dsObj.pageCount(); //Get property value.
	 * 
	 * @return {Integer}
	 */
	pageCount: function() {
		return this._pageCount;
	},
	
<span id='jslet-data-Dataset-property-masterDataset'>	/**
</span>	 * @property
	 * 
	 * Get the master dataset object for &quot;Detail Dataset&quot;.
	 * 
	 *     @example
	 *     var propValue = dsObj.masterDataset(); //Get property value.
	 * 
	 * @return {jslet.data.Dataset}
	 */
	masterDataset: function(masterDataset) {
		if(masterDataset === undefined) {
			if(this._masterDataset) {
				return jslet.data.getDataset(this._masterDataset);
			} else {
				return null;
			}
		}
		this._masterDataset = masterDataset;
		return this;
	},
	
<span id='jslet-data-Dataset-property-masterField'>	/**
</span>	 * @property
	 * 
	 * Get the master field name for &quot;Detail Dataset&quot;.
	 * 
	 *     @example
	 *     var propValue = dsObj.masterField(); //Get property value.
	 * 
	 * @return {String}
	 */
	masterField: function(masterField) {
		if(masterField === undefined) {
			return this._masterField;
		}
		jslet.Checker.test('Dataset.masterField', masterField).isString();
		this._masterField = masterField;
		return this;
	},
	
<span id='jslet-data-Dataset-property-getMasterFieldObject'>	/**
</span>	 * @property
	 * 
	 * Get the master field object.
	 * 
	 *     @example
	 *     var propValue = dsObj.getMasterFieldObject(); //Get property value.
	 * 
	 * @return {jslet.data.Field} Master field object.
	 */
	getMasterFieldObject: function() {
		if(this._masterField) {
			return this.masterDataset().getField(this._masterField);
		}
		return null;
	},
	
<span id='jslet-data-Dataset-method-designMode'>	/**
</span>	 * @private
	 * 
	 * Identify whether dataset is in desin mode.
	 * 
	 * @param {Boolean | undefined} designMode.
	 * 
	 * @return {this | Boolean}
	 */
	designMode: function(designMode) {
		if (designMode === undefined) {
			return this._designMode;
		}
		
		this._designMode = designMode ? true: false;
		return this;
	},
	
<span id='jslet-data-Dataset-property-autoShowError'>	/**
</span>	 * @property
	 * 
	 * Identify whether alerting the error message when apply changes to server.
	 * &lt;br /&gt;Default value: true.
	 * 
	 *     @example
	 *     dsObj.autoShowError(true); //Set property, return this.
	 *     var propValue = dsObj.autoShowError(); //Get property value.
	 * 
	 * @param {Boolean | undefined} autoShowError.
	 * 
	 * @return {this | Boolean}
	 */
	autoShowError: function(autoShowError) {
		if (autoShowError === undefined) {
			return this._autoShowError;
		}
		
		this._autoShowError = autoShowError ? true: false;
		return this;
	},
	
<span id='jslet-data-Dataset-property-autoRefreshHostDataset'>	/**
</span>	 * @property
	 * 
	 * Update the host dataset or not if this dataset is a lookup dataset and its data has changed.&lt;br /&gt;
	 * If true, all datasets which host this dataset will be refreshed.
	 * &lt;br /&gt;Default value: false.
	 * 
	 *     @example
	 *     dsObj.autoRefreshHostDataset(true); //Set property, return this.
	 *     var propValue = dsObj.autoRefreshHostDataset(); //Get property value.
	 * 
	 * @param {Boolean | undefined} flag.
	 * 
	 * @return {this | Boolean}
	 */
	autoRefreshHostDataset: function(flag) {
		if(flag === undefined) {
			return this._autoRefreshHostDataset;
		}
		this._autoRefreshHostDataset = flag ? true: false;
		return this;
	},
	
<span id='jslet-data-Dataset-property-unitConvertFactor'>	/**
</span>	 * @property
	 * 
	 * Set unit converting factor.
	 * 
	 * @param {Number} factor When changed this value, the field's display value will be changed by 'fldValue/factor'.
	 * @param {String} unitName Unit name that displays after field value.
	 * 
	 * @return {this}
	 */
	unitConvertFactor: function (factor, unitName) {
		var Z = this;
		if (arguments.length === 0) {
			return Z._unitConvertFactor;
		}
		
		jslet.Checker.test('Dataset.unitConvertFactor#factor', factor).isGTZero();
		jslet.Checker.test('Dataset.unitConvertFactor#unitName', unitName).isString();
		if (factor &gt; 0) {
			Z._unitConvertFactor = factor;
		}
		else{
			Z._unitConvertFactor = 1;
		}

		Z._unitName = unitName;
		for (var i = 0, cnt = Z._normalFields.length, fldObj; i &lt; cnt; i++) {
			fldObj = Z._normalFields[i];
			if (fldObj.getType() == jslet.data.DataType.NUMBER &amp;&amp; fldObj.unitConverted()) {
				var fldName = fldObj.name();
				jslet.data.FieldValueCache.clearAll(Z, fldName);
				var evt = jslet.data.RefreshEvent.updateColumnEvent(fldName);
				Z.refreshControl(evt);
			}
		} //end for
		return Z;
	},

<span id='jslet-data-Dataset-property-valueFollowEnabled'>	/**
</span>	 * @property
	 * 
	 * Identify whether enable value following when append record or not. This property is control the field's property &quot;valueFollow&quot;.
	 * 
	 * @param {Boolean | undefined} valueFollowEnabled True -(Default) enable value following, false - otherwise.
	 * 
	 * @return {this | Boolean} 
	 */
	valueFollowEnabled: function(valueFollowEnabled) {
		if(valueFollowEnabled === undefined) {
			return this._valueFollowEnabled;
		}
		this._valueFollowEnabled = valueFollowEnabled;
		return this;
	},
	
<span id='jslet-data-Dataset-property-datasetListener'>	/**
</span>	 * @property
	 * 
	 * Set or get dataset event listener. Example:
	 * 
	 *     @example
	 *     dsFoo.datasetListener(function(eventType, dataset) {
	 *		 console.log(eventType);
	 *     });
	 * 
	 * @param {Function} listener Dataset event listener.
	 * @param {jslet.data.DatasetEvent} listener.eventType Event type.
	 * @param {jslet.data.Dataset} listener.dataset Dataset object.
	 * 
	 * @return {this | Function}
	 */
	datasetListener: function(listener) {
		if (arguments.length === 0) {
			return this._datasetListener;
		}
		
		this._datasetListener = listener;
		return this;
	},
	
<span id='jslet-data-Dataset-method-on'>	/**
</span>	 * Add event handler for dataset events. Example:
	 * 
	 *     @example
	 *     var handler = function() {
	 *         console.log('After scroll event fired!');
	 *     };
	 *     dsObj.on('afterScroll', handler);
	 * 
	 * @param {jslet.data.DatasetEvent | String} eventName Event name.
	 * @param {Function | String} eventHanlder Event handler.
	 */
	on: function(eventName, eventHanlder) {
		jslet.Checker.test('Dataset.on#eventName', eventName).isString().required();
		jslet.Checker.test('Dataset.on#eventHanlder', eventHanlder).required();
		var Z = this;
		var dsHandlers = Z._datasetEventHandler;
		if(!dsHandlers) {
			dsHandlers = {};
			Z._datasetEventHandler = dsHandlers;
		}
		var evtHandlers = dsHandlers[eventName];
		if(!evtHandlers) {
			evtHandlers = [];
			dsHandlers[eventName] = evtHandlers;
		}
		evtHandlers.push(eventHanlder);
	},
	
<span id='jslet-data-Dataset-method-off'>	/**
</span>	 * Remove event handler. Example:
	 * 
	 *     @example
	 *     //Remove all event handlers.
	 *     dsObj.off();
	 *     
	 *     //Remove the specified event handlers.
	 *     dsObj.off('afterScroll');
	 *     
	 *     //Remove one event handler.
	 *     var handler = function() {
	 *         console.log('After scroll event fired!');
	 *     };
	 *     dsObj.on('afterScroll', handler);
	 *     dsObj.off('afterScroll', handler);
	 *     
	 * 
	 * @param {jslet.data.DatasetEvent | String} eventName Event name.
	 * @param {Function | String} eventHanlder Event handler.
	 */
	off: function(eventName, eventHanlder) {
		var dsHandlers = this._datasetEventHandler;
		if(!dsHandlers) {
			return;
		}
		if(!eventName &amp;&amp; !eventHanlder) {
			this._datasetEventHandler = null;
			return;
		}
		if(!eventName) {
			return;
		} 
		var evtHandlers = dsHandlers[eventName];
		if(!evtHandlers) {
			return;
		}
		if(!eventHanlder) {
			dsHandlers[eventName] = null;
			delete dsHandlers[eventName];
		} else {
			var handler;
			for(var i = 0, len = evtHandlers.length; i &lt; len; i++) {
				handler = evtHandlers[i];
				if(eventHanlder === handler) {
					evtHandlers.splice(i, 1);
				}
			}
		}
	},
	
<span id='jslet-data-Dataset-event-onCheckSelectable'>	/**
</span>	 * @event
	 * 
	 * Fired when check a record if it's selectable or not. Example:
	 * 
	 *     @example
	 *     dsObj.onCheckSelectable(function(recno) {
	 *       return true;
	 *     });
	 *  
	 * @param {Function | undefined} onCheckSelectable Check selectable event.
	 * @param {Boolean} onCheckSelectable.recno Record number. 
	 * @param {Boolean} onCheckSelectable.return Identify whether the record is selectable or not, true - record can be selected, false - otherwise.
	 * 
	 * @return {this | Function}
	 */
	onCheckSelectable: function(onCheckSelectable) {
		if (onCheckSelectable === undefined) {
			return this._onCheckSelectable;
		}
		
		this._onCheckSelectable = onCheckSelectable;
		return this;
	},
	
<span id='jslet-data-Dataset-event-onDataQuerying'>	/**
</span>	 * @event
	 * 
	 * Fired when querying data from server.
	 * 
	 *     @example
	 *     dsObj.onDataQuerying(function(queryResult) {
	 *       
	 *     });
	 *  
	 * @param {Function | undefined} onDataQuerying Data quering event.
	 * @param {Object} onDataQuerying.queryResult The data from server.
	 * 
	 * @return {this | Function}
	 */
	onDataQuerying: function(onDataQuerying) {
		if (onDataQuerying === undefined) {
			return this._onDataQuerying;
		}
		
		this._onDataQuerying = onDataQuerying;
		return this;
	},
	
<span id='jslet-data-Dataset-event-onDataQueried'>	/**
</span>	 * @event
	 * 
	 * Fired after querying data from server.
	 * 
	 *     @example
	 *     dsObj.onDataQueried(function() {
	 *       
	 *     });
	 *  
	 * @param {Function | undefined} onDataQueried Data queried event.
	 * 
	 * @return {this | Function}
	 */
	onDataQueried: function(onDataQueried) {
		if (onDataQueried === undefined) {
			return this._onDataQueried;
		}
		
		this._onDataQueried = onDataQueried;
		return this;
	},
	
<span id='jslet-data-Dataset-event-onDataSubmitted'>	/**
</span>	 * @event
	 * 
	 * Fired after submitting data to server.
	 * 
	 *     @example
	 *     dsObj.onDataSubmitted(function() {
	 *       
	 *     });
	 *  
	 * @param {Function | undefined} onDataSubmitted Data submitted event.
	 * 
	 * @return {this | Function}
	 */
	onDataSubmitted: function(onDataSubmitted) {
		if (onDataSubmitted === undefined) {
			return this._onDataSubmitted;
		}
		
		this._onDataSubmitted = onDataSubmitted;
		return this;
	},

<span id='jslet-data-Dataset-method-fieldValidator'>	/**
</span>	 * @private
	 */
	fieldValidator: function() {
		return this._fieldValidator;
	},
	
<span id='jslet-data-Dataset-event-onFieldChanged'>	/**
</span>	 * @event
	 * 
	 * Set or get dataset onFieldChanged event handler. Example:
	 * 
	 *     @example
	 *     dsFoo.onFieldChanged(function(fldName, value, valueIndex) {
	 *     });
	 * 
	 * @param {Function} onFieldChanged Dataset on field change event handler.
	 * @param {String} onFieldChanged.fldName Field name.
	 * @param {Object} onFieldChanged.fldValue Field value.
	 * @param {Integer} onFieldChanged.valueIndex Field value index, only worked when field value style is BETWEEN or MULTIPLE.
	 * 
	 * @return {this | Function}
	 */
	onFieldChanged: function(onFieldChanged) {
		if (onFieldChanged === undefined) {
			return this._onFieldChanged;
		}
		
		this._onFieldChanged = onFieldChanged;
		return this;
	},
	
<span id='jslet-data-Dataset-method-onFieldChange'>	/**
</span>	 * @deprecated
	 * Use onFieldChanged instead.
	 */
	onFieldChange: function(onFieldChanged) {
		if (onFieldChanged === undefined) {
			return this._onFieldChanged;
		}
		
		this._onFieldChanged = onFieldChanged;
		return this;
	},
	
	onFieldFocusing: function(onFieldFocusing) {
		if(onFieldFocusing === undefined) {
			return this._onFieldFocusing;
		}
		this._onFieldFocusing = onFieldFocusing;
		return this;
	},
	
<span id='jslet-data-Dataset-method-isFireGlobalEvent'>	/**
</span>	 * Identify if firing global event or not when field value or field meta changed.
	 */
	isFireGlobalEvent: function(isFireGlobalEvent) {
		if(isFireGlobalEvent === undefined) {
			return this._isFireGlobalEvent;
		}
		this._isFireGlobalEvent = isFireGlobalEvent? true: false;
		return this;
	},
	
<span id='jslet-data-Dataset-method-getFields'>	/**
</span>	 * Get dataset fields.
	 * 
	 * @return {jslet.data.Field[]} Dataset fields.
	 */
	getFields: function () {
		return this._fields;
	},

<span id='jslet-data-Dataset-method-getNormalFields'>	/**
</span>	 * Get fields which is without child fields.
	 * 
	 * @return {jslet.data.Field[]}
	 */
	getNormalFields: function() {
		return this._normalFields;
	},
	
<span id='jslet-data-Dataset-method-getEditableFields'>	/**
</span>	 * Get field names exclude the fields with children.
	 * 
	 * @return {String[]} Editable field names.
	 */
	getEditableFields: function() {
		var fields = this._normalFields,
			fldObj,
			result = [];
		
		for(var i = 0, len = fields.length; i &lt; len; i++) {
			fldObj = fields[i];
			if(fldObj.visible() &amp;&amp; !fldObj.disabled() &amp;&amp; !fldObj.readOnly()) {
				result.push(fldObj.name());
			}
		}
		return result;
	},
	
	getFirstFocusField: function() {
		var Z = this;
		var fields = Z.mergedFocusedFields();
		if(fields &amp;&amp; fields.length &gt; 0) {
			return fields[0];
		}
		fields = Z.getEditableFields();
		if(fields &amp;&amp; fields.length &gt; 0) {
			return fields[0];
		}
	},
	
<span id='jslet-data-Dataset-method-setVisibleFields'>	/**
</span>	 * Set the specified fields to be visible, others to be hidden. Example:
	 * 
	 *     @example
	 *     dsFoo.setVisibleFields(['field1', 'field3']);
	 * 
	 * @param {String[]} visibleFields Array of visible field name.
	 * 
	 * @return {this}
	 */
	setVisibleFields: function(fieldNameArray) {
		if(!fieldNameArray) {
			return this;
		}
		if(jslet.isString(fieldNameArray)) {
			fieldNameArray = fieldNameArray.split(',');
		}
		jslet.Checker.test('Dataset.setVisibleFields#fieldNameArray', fieldNameArray).isArray();
		this._travelField(this._fields, function(fldObj) {
			fldObj.visible(false);
			return false; //Identify if cancel traveling or not
		});
		for(var i = 0, len = fieldNameArray.length; i &lt; len; i++) {
			var fldName = jslet.trim(fieldNameArray[i]);
			var fldObj = this.getField(fldName);
			if(fldObj) {
				fldObj.visible(true);
			}
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-_travelField'>	/**
</span>	 * @private
	 */
	_travelField: function(fields, callBackFn) {
		if (!callBackFn || !fields) {
			return;
		}
		var isBreak = false;
		for(var i = 0, len = fields.length; i &lt; len; i++) {
			var fldObj = fields[i];
			isBreak = callBackFn(fldObj);
			if (isBreak) {
				break;
			}
			
			var children = fldObj.children();
			if(children &amp;&amp; children.length &gt; 0) {
				isBreak = this._travelField(fldObj.children(), callBackFn);
				if (isBreak) {
					break;
				}
			}
		}
		return isBreak;
	},
	
<span id='jslet-data-Dataset-method-_cacheNormalFields'>	/**
</span>	 * @private
	 */
	_cacheNormalFields: function() {
		var arrFields = this._normalFields = [];
		this._travelField(this._fields, function(fldObj) {
			var children = fldObj.children();
			var dataType = fldObj.dataType();
			if((!children || children.length === 0) &amp;&amp; dataType !== jslet.data.DataType.ACTION &amp;&amp; dataType !== jslet.data.DataType.EDITACTION) {
				arrFields.push(fldObj);
			}
			return false; //Identify if cancel traveling or not
		});
		this._normalFields = arrFields;
		this.calcFocusedFields();
	},
	
<span id='jslet-data-Dataset-method-addFields'>	/**
</span>	 * Add some field objects.
	 * 
	 * @param {jslet.data.Field[]} fldObjs Field objects.
	 * 
	 * @return {this}
	 */
	addFields: function(arrFldObj) {
		jslet.Checker.test('Dataset.addFields#arrFldObj', arrFldObj).required().isArray();
		var Z = this,
			len = arrFldObj.length;
		if(len === 0) {
			return Z;
		}
		for(var i = 0; i &lt; len; i++) {
			Z.addField(arrFldObj[i], true);
		}
		Z.refreshDisplayOrder();
		Z.refreshAggregatedFields();
		return this;
	},
	
<span id='jslet-data-Dataset-method-addField'>	/**
</span>	* Add an exist field object. If creating a new field, use &quot;createField&quot; instead.
	* 
	*     @example
	*     dsObj.addField(fldObj);
	* 
	* @param {jslet.data.Field} fldObj Field object.
	* 
	* @return {this}
	*/
	addField: function (fldObj, batchMode) {
		jslet.Checker.test('Dataset.addField#fldObj', fldObj).required().isClass(jslet.data.Field.className);
		var Z = this,
			fldName = fldObj.name();
		if(Z.getField(fldName)) {
			Z.removeField(fldName);
		}
		fldObj.dataset(Z);
		Z._fields.push(fldObj);
		var dispOrder = fldObj.displayOrder(); 
		if (!dispOrder &amp;&amp; dispOrder !== 0) {
			fldObj.displayOrder(Z._fields.length);
		}
		var dataType = fldObj.dataType();
		if (dataType == jslet.data.DataType.DATASET) {
			if (!Z._detailDatasetFields) {
				Z._detailDatasetFields = [];
			}
			Z._detailDatasetFields.push(fldObj);
		}
		if (dataType == jslet.data.DataType.PROXY) {
			if (!Z._proxyFields) {
				Z._proxyFields = [];
			}
			Z._proxyFields.push(fldObj);
		}
		
		function addFormulaField(fldName, fldObj) {
			var children = fldObj.children();
			if(!children || children.length === 0) {
				Z._fieldsMap[fldName] = fldObj;
				Z.addInnerFormulaField(fldName, fldObj.formula());
				return;
			}
			var childFldObj;
			for(var i = 0, len = children.length; i &lt; len; i++) {
				childFldObj = children[i]; 
				addFormulaField(childFldObj.name, childFldObj);
			}
		}
		
		addFormulaField(fldName, fldObj);
		
		if(!batchMode) {
			Z.refreshDisplayOrder();
			Z.refreshAggregatedFields();
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-addFieldFromDataset'>	/**
</span>	 * Add specified fields of source dataset into this dataset.
	 * 
	 *     @example
	 *     var srcDsObj = jslet.data.getDataset('srcDataset');
	 *     dsObj.addFieldFromDataset(srcDsObj, ['fld1', 'fld2']);
	 * 
	 * @param {jslet.data.Dataset} srcDataset Source dataset where fields are added from.
	 * @param {String[]} fieldNames A list of field names which are copied to this dataset.
	 * 
	 * @return {this}
	 */
	addFieldFromDataset: function(srcDataset, fieldNames) {
		jslet.Checker.test('Dataset.addFieldFromDataset#srcDataset', srcDataset).required().isClass(jslet.data.Dataset.className);
		jslet.Checker.test('Dataset.addFieldFromDataset#fieldNames', fieldNames).isArray();
		var Z = this,
			fldObj, fldName, 
			srcFields = srcDataset.getFields();
		for(var i = 0, cnt = srcFields.length; i &lt; cnt; i++) {
			fldObj = srcFields[i];
			fldName = fldObj.name();
			if (fieldNames) {
				if (fieldNames.indexOf(fldName) &lt; 0) {
					continue;
				}
			}
			this.addField(fldObj.clone(fldName, this), true);
		}
		Z.refreshDisplayOrder();
		Z.refreshAggregatedFields();
		return this;
	},
	
	refreshDisplayOrder: function() {
		this._fields.sort(jslet.data.displayOrderComparator);
		this._cacheNormalFields();
		return this;
	},
	
	moveField: function(fromFldName, toFldName) {
		var Z = this,
			fromFldObj = Z.getField(fromFldName),
			toFldObj = Z.getField(toFldName),
			fromParent = fromFldObj.parent(),
			toParent = toFldObj.parent();
		if(!fromFldObj || !toFldObj || fromParent != toParent) {
			return this;
		}
		var fields;
		if(fromParent) {
			fields = fromParent.children();
		} else {
			fields = Z._fields;
		}
		var fldObj, fldName, i,
			fromOrder = fromFldObj.displayOrder(),
			toOrder = toFldObj.displayOrder(),
			fromIndex = fields.indexOf(fromFldObj),
			toIndex = fields.indexOf(toFldObj),
			oldDesignMode = Z.designMode();
		Z.designMode(false);
		try {
			fromFldObj.displayOrder(toFldObj.displayOrder());
			if(fromIndex &lt; toIndex) {
				for(i = fromIndex + 1; i &lt;= toIndex; i++) {
					fldObj = fields[i];
					fldObj.displayOrder(fldObj.displayOrder() - 1);
				}
			} else {
				for(i = toIndex; i &lt; fromIndex; i++) {
					fldObj = fields[i];
					fldObj.displayOrder(fldObj.displayOrder() + 1);
				}
			}
		} finally {
			Z.designMode(oldDesignMode);
		}
		Z.refreshDisplayOrder();
		if(Z.designMode() &amp;&amp; Z.isFireGlobalEvent()) {
			var handler = jslet.data.globalDataHandler.fieldMetaChanged();
			if(handler) {
				handler.call(this, Z, null, 'displayOrder');
			}
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-removeField'>	/**
</span>	 * Remove field by field name.
	 * 
	 * @param {String} fldName Field name.
	 * 
	 * @return {this}
	 */
	removeField: function (fldName) {
		function removeFormulaField(fldName, fldObj) {
			var children = fldObj.children();
			if(!children || children.length === 0) {
				delete Z._fieldsMap[fldName];
				Z.removeInnerFormulaField(fldName);
				return this;
			}
			var childFldObj;
			for(var i = 0, len = children.length; i &lt; len; i++) {
				childFldObj = children[i];
				removeFormulaField(childFldObj.name(), childFldObj);
			}
		}

		jslet.Checker.test('Dataset.removeField#fldName', fldName).required().isString();
		fldName = jslet.trim(fldName);
		var Z = this,
			fldObj = Z.getField(fldName);
		if (fldObj) {
			if (fldObj.dataType() == jslet.data.DataType.DATASET) {
				var k = Z._detailDatasetFields.indexOf(fldObj);
				if (k &gt;= 0) {
					Z._detailDatasetFields.splice(k, 1);
				}
			}
			var i = Z._fields.indexOf(fldObj);
			if(i &gt;= 0) {
				Z._fields.splice(i, 1);
			}
			fldObj.dataset(null);
			Z._cacheNormalFields();
			jslet.data.FieldValueCache.clearAll(Z, fldName);

			removeFormulaField(fldName, fldObj);
			Z.refreshAggregatedFields();
		}
		var parentFldObj = fldObj.parent();
		if(parentFldObj) {
			var children = parentFldObj.children();
			var k = children.indexOf(fldObj);
			children.splice(k, 1);
		}
		return this;
	},

<span id='jslet-data-Dataset-method-clearFields'>	/**
</span>	 * Clear all fields.
	 */
	clearFields: function(fields) {
		if (!fields) {
			fields = this._fields;
		}
		var start = fields.length - 1;
		for(var i = start; i &gt;= 0; i--) {
			var fldObj = fields[i];
			var children = fldObj.children();
			if(children &amp;&amp; children.length &gt; 0) {
				this.clearFields(children);
			}
			this.removeField(fldObj.name());
		}
		return this;
	},
	
	refreshAggregatedFields: function() {
		var Z = this;
		Z._aggregatedFields = null;
		var fields = Z.getNormalFields(), 
			fldObj, aggregatedFields = [];
		for(var i = 0, len = fields.length; i&lt; len; i++) {
			fldObj = fields[i];
			if(fldObj.aggregated()) {
				aggregatedFields.push(fldObj);
			}
		}
		if(aggregatedFields.length &gt; 0) {
			Z._aggregatedFields = aggregatedFields;
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-getField'>	/**
</span>	 * Get field object by name.
	 * 
	 * @param {String} fldName Field name.
	 * 
	 * @return jslet.data.Field
	 */
	getField: function (fldName) {
		jslet.Checker.test('Dataset.getField#fldName', fldName).isString().required();
		fldName = jslet.trim(fldName);

		var arrField = fldName.split('.'), fldName1 = arrField[0], foundInMap = true;
		var fldObj = this._fieldsMap[fldName1];
		if(!fldObj) {
			foundInMap = false;
			this._travelField(this._fields, function(fldObj1) {
				var cancelTravel = false;
				if (fldObj1.name() == fldName1) {
					fldObj = fldObj1;
					cancelTravel = true;
				}
				return cancelTravel; //Identify if cancel traveling or not
			});
		}
		if (!fldObj) {
			return null;
		}
		if(!foundInMap) {
			this._fieldsMap[fldName1] = fldObj;
		}
		if (arrField.length == 1) {
			return fldObj;
		}
		else {
			arrField.splice(0, 1);
			var lkf = fldObj.lookup();//Lookup dataset
			if (lkf) {
				var lkds = lkf.dataset();
				if (lkds) {
					return lkds.getField(arrField.join('.'));
				}
			} else {
				var dsDetail = fldObj.detailDataset(); //Detail dataset
				if(dsDetail) {
					return dsDetail.getField(arrField.join('.'));
				}
			}
		}
		return null;
	},

<span id='jslet-data-Dataset-method-getTopField'>	/**
</span>	 * Get top field object by name.
	 * 
	 * @param {String} fldName Field name.
	 * 
	 * @return jslet.data.Field
	 */
	getTopField: function (fldName) {
		jslet.Checker.test('Dataset.getField#fldName', fldName).isString().required();
		fldName = jslet.trim(fldName);
		
		var fldObj = this.getField(fldName);
		if (fldObj) {
			while(true) {
				if (fldObj.parent() === null) {
					return fldObj;
				}
				fldObj = fldObj.parent();
			}
		}
		return null;
	},
	
<span id='jslet-data-Dataset-method-sortFunc'>	/**
</span>	 * @private
	 * Sort function.
	 * 
	 * @param {Object} rec1: dataset record.
	 * @param {Object} rec2: dataset record.
	 */
	sortFunc: function (rec1, rec2) {
		var dsObj = jslet.temp.sortDataset;
		
		var indexFlds = dsObj._sortingFields,
			strFields = [],
			fname, idxFldCfg, i, cnt;
		for (i = 0, cnt = indexFlds.length; i &lt; cnt; i++) {
			idxFldCfg = indexFlds[i];
			fname = idxFldCfg.fieldName;
			if(idxFldCfg.useTextToSort || dsObj.getField(fname).getType() === jslet.data.DataType.STRING) {
				strFields.push(fname);
			}
		}
		var  v1, v2, flag = 1;
		for (i = 0, cnt = indexFlds.length; i &lt; cnt; i++) {
			idxFldCfg = indexFlds[i];
			fname = idxFldCfg.fieldName;
			if(idxFldCfg.useTextToSort) {
				v1 = dsObj.getFieldTextByRecord(rec1, fname);
				v2 = dsObj.getFieldTextByRecord(rec2, fname);
			} else {
				v1 = dsObj.getFieldValueByRecord(rec1, fname);
				v2 = dsObj.getFieldValueByRecord(rec2, fname);
			}
			if (v1 == v2) {
				continue;
			}
			if (v1 !== null &amp;&amp; v2 !== null) {
				if(strFields.indexOf(fname) &gt;= 0) {
					v1 = v1.toLowerCase();
					v2 = v2.toLowerCase();
					flag = (v1.localeCompare(v2) &lt; 0? -1: 1);
				} else {
					flag = (v1 &lt; v2 ? -1: 1);
				}
			} else if (v1 === null &amp;&amp; v2 !== null) {
				flag = -1;
			} else {
				if (v1 !== null &amp;&amp; v2 === null) {
					flag = 1;
				}
			}
			return flag * idxFldCfg.order;
		} //end for
		return 0;
	},
	
<span id='jslet-data-Dataset-property-fixedIndexFields'>	/**
</span>	 * @property
	 * 
	 * Set or get fixed index fields, field names separated by comma(','). &lt;br /&gt;
	 * If this property is set, data records will be ordered by properties: fixedIndexFields and indexFields. &lt;br /&gt;
	 * Diffence of fixedIndexFields and indexFields: indexFields can changed by UI control dynamically(like clicking the column head of {@link jslet.ui.DBTable}), and fixedIndexFields won't.&lt;br /&gt;
	 * Example:
	 * 
	 *     @example
	 *     dsObj.fixedIndexFields('fld2,fld3'); //Set property, return this.
	 *     var propValue = dsObj.fixedIndexFields(); //Get property value.
	 * 
	 * @param {String | undefined} fixedIndexFields Fixed index field name.
	 * 
	 * @return {this | String}
	 */
	fixedIndexFields: function (fixedIndexFields) {
		var Z = this;
		if (fixedIndexFields === undefined) {
			return Z._fixedIndexFields;
		}
		
		jslet.Checker.test('Dataset.fixedIndexFields', fixedIndexFields).isString();
		
		Z._fixedIndexFields = fixedIndexFields? jslet.trim(fixedIndexFields): null;
		Z._innerFixedIndexFields = fixedIndexFields? Z._parseIndexFields(fixedIndexFields): [];
		var idxFld, fixedIdxFld;
		for(var i = Z._innerIndexFields.length - 1; i&gt;=0; i--) {
			idxFld = Z._innerIndexFields[i];
			for(var j = 0, len = Z._innerFixedIndexFields.length; j &lt; len; j++) {
				fixedIdxFld = Z._innerFixedIndexFields[j];
				if(idxFld.fieldName === fixedIdxFld.fieldName) {
					Z._innerIndexFields.splice(i, 1);
				}
			}
		}
		
		Z._sortByFields();
		return Z;
	},
	
<span id='jslet-data-Dataset-property-indexFields'>	/**
</span>	 * @property
	 * 
	 * Set or get index fields, field names separated by comma(','). &lt;br /&gt;
	 * If this property is set, data records will be ordered by properties: fixedIndexFields and indexFields. &lt;br /&gt;
	 * Diffence of fixedIndexFields and indexFields: indexFields can changed by UI control dynamically(like clicking the column head of {@link jslet.ui.DBTable}), and fixedIndexFields won't.&lt;br /&gt;
	 * Example:
	 * 
	 *     @example
	 *     dsObj.indexFields('fld2,fld3'); //Set property, return this.
	 *     var propValue = dsObj.indexFields(); //Get property value.
	 * 
	 * @param {String | undefined} indexFields Index field name.
	 * 
	 * @return {this | String}
	 */
	indexFields: function (indFlds) {
		var Z = this;
		if (indFlds === undefined) {
			return Z._indexFields;
		}
		
		jslet.Checker.test('Dataset.indexFields', indFlds).isString();
		indFlds = indFlds? jslet.trim(indFlds): null;
		if(!indFlds &amp;&amp; !Z._indexFields &amp;&amp; !Z._fixedIndexFields) {
			return this;
		}

		Z._indexFields = indFlds;
		Z._innerIndexFields = indFlds? Z._parseIndexFields(indFlds): [];
		var idxFld, fixedIdxFld;
		for(var i = Z._innerIndexFields.length - 1; i&gt;=0; i--) {
			idxFld = Z._innerIndexFields[i];
			for(var j = 0, len = Z._innerFixedIndexFields.length; j &lt; len; j++) {
				fixedIdxFld = Z._innerFixedIndexFields[j];
				if(idxFld.fieldName === fixedIdxFld.fieldName) {
					fixedIdxFld.order = idxFld.order;
					Z._innerIndexFields.splice(i, 1);
				}
			}
		}
		Z._sortByFields();
		return Z;
	},

	mergedIndexFields: function() {
		var Z = this, i, len,
			result = [];
		for(i = 0, len = Z._innerFixedIndexFields.length; i &lt; len; i++) {
			result.push(Z._innerFixedIndexFields[i]);
		}
		for(i = 0, len = Z._innerIndexFields.length; i &lt; len; i++) {
			result.push(Z._innerIndexFields[i]);
		}
		return result;
	},
	
	toggleIndexField: function(fldName, emptyIndexFields) {
		var Z = this,
			idxFld, i, 
			found = false;
		//Check fixed index fields
		for(i = Z._innerFixedIndexFields.length - 1; i&gt;=0; i--) {
			idxFld = Z._innerFixedIndexFields[i];
			if(idxFld.fieldName === fldName) {
				idxFld.order = (idxFld.order === 1 ? -1: 1);
				found = true;
				break;
			}
		}
		if(found) {
			if(emptyIndexFields) {
				Z._innerIndexFields = [];
			}
			Z._sortByFields();
			return;
		}
		//Check index fields
		found = false;
		for(i = Z._innerIndexFields.length - 1; i&gt;=0; i--) {
			idxFld = Z._innerIndexFields[i];
			if(idxFld.fieldName === fldName) {
				idxFld.order = (idxFld.order === 1 ? -1: 1);
				found = true;
				break;
			}
		}
		if(found) {
			if(emptyIndexFields) {
				Z._innerIndexFields = [];
				Z._innerIndexFields.push(idxFld);
			}
		} else {
			if(emptyIndexFields) {
				Z._innerIndexFields = [];
			}
			idxFld = {fieldName: fldName, order: 1};
			Z._innerIndexFields.push(idxFld);
		}
		Z._sortByFields();
	},
	
	_parseIndexFields: function(indexFields) {
		var arrFields = indexFields.split(','), 
			fname, fldObj, arrFName, indexNameObj, 
			order = 1;//asce
		var result = [];
		for (var i = 0, cnt = arrFields.length; i &lt; cnt; i++) {
			fname = jslet.trim(arrFields[i]);
			arrFName = fname.split(' ');
			if (arrFName.length == 1) {
				order = 1;
			} else if (arrFName[1].toLowerCase() == 'asce') {
				order = 1; //asce
			} else {
				order = -1; //desc
			}
			result.push({fieldName: arrFName[0], order: order});
		} //end for
		return result;
	},
	
	_sortByFields: function() {
		var Z = this;
		if (!Z.hasRecord()) {
			return;
		}
		Z.selection.removeAll();

		Z._sortingFields = [];
		var idxFld, i, cnt;
		for (i = 0, cnt = Z._innerFixedIndexFields.length; i &lt; cnt; i++) {
			idxFld = Z._innerFixedIndexFields[i];
			Z._createIndexCfg(idxFld.fieldName, idxFld.order);
		} //end for
		for (i = 0, cnt = Z._innerIndexFields.length; i &lt; cnt; i++) {
			idxFld = Z._innerIndexFields[i];
			Z._createIndexCfg(idxFld.fieldName, idxFld.order);
		} //end for

		if(Z._sortingFields.length === 0) {
			return;
		}
		var currRec = Z.getRecord(), 
			flag = Z.isContextRuleEnabled();
		if (flag) {
			Z.disableContextRule();
		}
		Z.disableControls();
		jslet.temp.sortDataset = Z;
		try {
			Z.records().sort(Z.sortFunc);
			Z._refreshInnerRecno();
		} finally {
			jslet.temp.sortDataset = null;
			Z.moveToRecord(currRec);
			if (flag) {
				Z.enableContextRule();
			}
			Z.enableControls();
		}		
	},
	
<span id='jslet-data-Dataset-method-_createIndexCfg'>	/**
</span>	 * @private
	 */
	_createIndexCfg: function(fname, order) {
		var Z = this,
			fldObj = fname;
		if(jslet.isString(fname)) {
			fldObj = Z.getField(fname);
		}
		if (!fldObj) {
			return;
		}
		if(fldObj.dataset() !== Z) {
			Z._combineIndexCfg(fname, order);
			return;
		}
		var children = fldObj.children();
		if (!children || children.length === 0) {
			var useTextToSort = true;
			if(fldObj.getType() === 'N' &amp;&amp; !fldObj.lookup()) {
				useTextToSort = false;
			}
			Z._combineIndexCfg(fldObj.name(), order, useTextToSort);
		} else {
			for(var k = 0, childCnt = children.length; k &lt; childCnt; k++) {
				Z._createIndexCfg(children[k], order);
			}
		}		
	},
	
<span id='jslet-data-Dataset-method-_combineIndexCfg'>	/**
</span>	 * @private
	 */
	_combineIndexCfg: function(fldName, order, useTextToSort) {
		for(var i = 0, len = this._sortingFields.length; i &lt; len; i++) {
			if (this._sortingFields[i].fieldName == fldName) {
				this._sortingFields.splice(i,1);//remove duplicated field
			}
		}
		var indexNameObj = {
				fieldName: fldName,
				order: order,
				useTextToSort: useTextToSort
			};
		this._sortingFields.push(indexNameObj);
	},
	
	_getWholeFilter: function() {
		var Z = this, 
			result = Z._fixedFilter;
		if(result) {
			if(Z._filter) {
				return '(' + result + ') &amp;&amp; (' + Z._filter + ')';
			}
		} else {
			result = Z._filter;
		}
		return result;
	},
	
<span id='jslet-data-Dataset-property-fixedFilter'>	/**
</span>	 * @property
	 * 
	 * Set or get dataset fixed filter expression.&lt;br /&gt;
	 * If this property is set, data records will be filtered by properties: fixedFilter and Filter. &lt;br /&gt;
	 * Diffence of fixedFilter and filter: filter can changed by UI control dynamically(like {@link jslet.ui.DBAutoComplete}, {@link jslet.ui.DBTable}), and fixedFilter won't.
	 * Example:
	 * 
	 *     @example
	 *     dsObj.fixedFilter('[age] &gt; 20'); //Set property, return this.
	 *     var propValue = dsObj.fixedFilter(); //Get property value.
	 * 
	 * @param {String | undefined} fixedFilter Fixed filter expression.
	 * 
	 * @return {this | String}
	 */
	fixedFilter: function (fixedFilter) {
		var Z = this;
		if (fixedFilter === undefined) {
			return Z._fixedFilter;
		}
		
		jslet.Checker.test('dataset.fixedFilter', fixedFilter).isString();
		if(fixedFilter) {
			fixedFilter = jslet.trim(fixedFilter);
		}
		var oldFilter = Z._getWholeFilter();
		Z._fixedFilter = fixedFilter;
		var newFilter = Z._getWholeFilter();
		
		if (!newFilter) {
			Z._innerFilter = null;
			Z._filtered = false;
			Z._filteredRecnoArray = null;
		} else {
			if(oldFilter == newFilter) {
				return this;
			} else {
				Z._innerFilter = new jslet.data.Expression(Z, newFilter);
			}
		}
		if(Z._filtered) {
			Z._doFilterChanged();
		}
		return this;
	},
	
<span id='jslet-data-Dataset-property-filter'>	/**
</span>	 * @property
	 * 
	 * Set or get dataset filter expression.&lt;br /&gt;
	 * If this property is set, data records will be filtered by properties: fixedFilter and Filter. &lt;br /&gt;
	 * Diffence of fixedFilter and filter: filter can changed by UI control dynamically(like {@link jslet.ui.DBAutoComplete}, {@link jslet.ui.DBTable}), and fixedFilter won't.
	 * Example:
	 * 
	 *     @example
	 *     dsObj.filter('[age] &gt; 20'); //Set property, return this.
	 *     dsObj.filter('[name] like &quot;Bob%&quot;');
	 *     var propValue = dsObj.filter(); //Get property value.
	 * 
	 * @param {String | undefined} filter Filter expression.
	 * 
	 * @return {this | String}
	 */
	filter: function (filterExpr) {
		var Z = this;
		if (filterExpr === undefined) {
			return Z._filter;
		}
		
		jslet.Checker.test('dataset.filter#filterExpr', filterExpr).isString();
		if(filterExpr) {
			filterExpr = jslet.trim(filterExpr);
		}

		var oldFilter = Z._getWholeFilter();
		Z._filter = filterExpr;
		var newFilter = Z._getWholeFilter();
		
		if (!newFilter) {
			Z._innerFilter = null;
			var oldFiltered = Z._filtered;
			Z._filtered = false;
			Z._filteredRecnoArray = null;
			if(oldFiltered) {
				Z._doFilterChanged();
			}
		} else {
			if(oldFilter == newFilter) {
				return this;
			} else {
				Z._innerFilter = new jslet.data.Expression(Z, newFilter);
			}
			if(Z._filtered) {
				Z._doFilterChanged();
			}
		}
		return this;
	},

<span id='jslet-data-Dataset-property-filtered'>	/**
</span>	 * @property
	 * 
	 * Set or get filtered flag. Only 'filtered' is true, 'filter' and 'fixedFilter' would work.&lt;br /&gt;
	 * Example:
	 * 
	 *     @example
	 *     dsObj.filter('[age] &gt; 20 &amp;&amp; [name] like &quot;Bob%&quot;');
	 *     dsObj.filtered(true); // Set property, return this.
	 *     var propValue = dsObj.filtered(); // Get property value.
	 * 
	 * @param {Boolean | undefined} filtered Filter flag.
	 * 
	 * @return {this | Boolean}
	 */
	filtered: function (afiltered) {
		var Z = this;
		if (afiltered === undefined) {
			return Z._filtered;
		}
		
		var oldFilter = Z._getWholeFilter(), 
			oldFiltered = Z._filtered;
		if (afiltered &amp;&amp; !oldFilter) {
			Z._filtered = false;
		} else {
			Z._filtered = afiltered ? true: false;
		}

		if(oldFiltered == Z._filtered) {
			return this;
		}
		this._doFilterChanged();
		return this;
	},
	
	_doFilterChanged: function() {
		var Z = this;
		Z.selection.removeAll();
		var flag = Z.isContextRuleEnabled();
		if (flag) {
			Z.disableContextRule();
		}
		Z.disableControls();
		try {
			if (!Z._filtered) {
				Z._filteredRecnoArray = null;
			} else {
				Z._refreshInnerRecno();
			}
		} finally {
			if(flag) {
				Z.enableContextRule();
			}
			Z.enableControls();
		}
		Z.first();
		Z._calcAggregatedValueDebounce.call(Z);		
		Z.refreshLookupHostDataset();

		return this;
	},
	
<span id='jslet-data-Dataset-method-_filterData'>	/**
</span>	 * @private, filter data
	 */
	_filterData: function () {
		var Z = this,
		 	filter = Z._getWholeFilter();
		if (!Z._filtered || !filter || 
				Z._status == jslet.data.DataSetStatus.INSERT || 
				Z._status == jslet.data.DataSetStatus.UPDATE) {
			return true;
		}
		var result = Z._innerFilter.eval();
		return result;
	},

<span id='jslet-data-Dataset-method-_refreshInnerRecno'>	/**
</span>	 * @private
	 */
	_refreshInnerRecno: function () {
		var Z = this;
		if (!Z.hasData()) {
			Z._filteredRecnoArray = null;
			return;
		}
		Z._filteredRecnoArray = null;
		if(!Z._filtered) {
			return;
		}
		var tempRecno = [];
		var oldRecno = Z._recno;
		try {
			for (var i = 0, cnt = Z.records().length; i &lt; cnt; i++) {
				Z._recno = i;
				if (Z._filterData()) {
					tempRecno.push(i);
				}
			}
		}
		finally {
			Z._recno = oldRecno;
		}
		Z._filteredRecnoArray = tempRecno;
	},

	_innerAfterScrollDebounce: function() {
		var Z = this,
			eventFunc = jslet.getFunction(Z._datasetListener);
		if(eventFunc) {
			eventFunc.call(Z, jslet.data.DatasetEvent.AFTERSCROLL);
		}
	},
	
<span id='jslet-data-Dataset-method-_fireDatasetEvent'>	/**
</span>	 * @private
	 */
	_fireDatasetEvent: function (evtType) {
		var Z = this;
		if (Z._silence || Z._igoreEvent) {
			return;
		}
		if(Z._datasetListener) {
			if(evtType == jslet.data.DatasetEvent.AFTERSCROLL) {
				Z._afterScrollDebounce.call(Z);
			} else {
				var eventFunc = jslet.getFunction(Z._datasetListener);
				if(eventFunc) {
					eventFunc.call(Z, evtType);
				}
			}
		}
		
		var dsHandlers = Z._datasetEventHandler;
		if(dsHandlers) {
			var evtHandlers = dsHandlers[evtType];
			if(evtHandlers) {
				for(var i = 0, len = evtHandlers.length; i &lt; len; i++) {
					var eventFunc = jslet.getFunction(evtHandlers[i]);
					if(eventFunc) {
						eventFunc.call(Z);
					}
				}
			}
		}

	},

<span id='jslet-data-Dataset-property-recordCount'>	/**
</span>	 * @property
	 * 
	 * Get record count.
	 * 
	 * @return {Integer}
	 */
	recordCount: function () {
		var records = this.records();
		if (records) {
			if (!this._filteredRecnoArray) {
				return records.length;
			} else {
				return this._filteredRecnoArray.length;
			}
		}
		return 0;
	},

<span id='jslet-data-Dataset-method-hasRecord'>	/**
</span>	 * Check whether dataset exists records.
	 * It checks on datase filter. 
	 * 
	 *     @example
	 *     //dsObj has 2 records first.
	 *     dsObj.hasRecord(); //return true
	 *     dsObj.filter('false'); //Filter out all records.
	 *     dsObj.filtered(true);
	 *     dsObj.hasRecord(); //return false
	 *     
	 * @return {Boolean}
	 */
	hasRecord: function () {
		return this.recordCount() &gt; 0;
	},
	
<span id='jslet-data-Dataset-method-hasData'>	/**
</span>	 * Check whether dataset exists records.
	 * It checks no matter whether dataset has filter or not. 
	 * 
	 *     @example
	 *     //dsObj has 2 records first.
	 *     dsObj.hasData(); //return true
	 *     dsObj.filter('false'); //Filter out all records.
	 *     dsObj.filtered(true);
	 *     dsObj.hasData(); //still return true
	 *     
	 * @return {Boolean}
	 */
	hasData: function() {
		var records = this.records();
		return records &amp;&amp; records.length &gt; 0;
	},
	
<span id='jslet-data-Dataset-property-recno'>	/**
</span>	 * @property
	 * 
	 * Set or get record number, record number starts with 0.&lt;br /&gt;
	 * Record number is relative to many data manuplating. Example:
	 * 
	 *     @example
	 *     var oldRecno = dsObj.recno();
	 *     dsObj.recno(2);
	 *     try {
	 *       dsObj.setFieldValue('fld1', 'test');
	 *     } finally {
	 *       dsObj.recno(oldRecno);
	 *     }
	 * 
	 * @param {Integer | undefined} recno Record number.
	 * @return {this | Integer}
	 */
	recno: function (recno) {
		var Z = this;
		if (recno === undefined) {
			if(Z.recordCount() &gt; 0) {
				return Z._recno;
			} else {
				return -1;
			}
		}
		jslet.Checker.test('dataset.recno#recno', recno).isGTEZero();
		recno = parseInt(recno);
		if(!Z.hasRecord()) {
			Z._bof = Z._eof = true;
			return true;
		}
		
		if (recno == Z._recno) {
			return true;
		}
		Z.confirm();
		Z._gotoRecno(recno);
		Z._bof = Z._eof = false;
		return true;
	},
	
<span id='jslet-data-Dataset-property-recnoSilence'>	/**
</span>	 * @property
	 * 
	 * Set or get record number silently, it will not fire any event.
	 * 
	 * @param {Integer | undefined} recno Record number.
	 * @return {this | Integer}
	 */
	recnoSilence: function (recno) {
		var Z = this;
		if (recno === undefined) {
			if(Z.recordCount() &gt; 0) {
				return Z._recno;
			} else {
				return -1;
			}
		}
		if(recno &lt; 0) {
			recno = 0;
		}
		var last = Z.recordCount() - 1;
		if(recno &gt; last) {
			recno = last;
		}
		Z._recno = recno &gt; last? last: recno;
		return this;
	},

<span id='jslet-data-Dataset-method-_gotoRecno'>	/**
</span>	 * @private
	 * Goto specified record number(Private)
	 * 
	 * @param {Integer}recno Record number.
	 */
	_gotoRecno: function (recno) {
		var Z = this,
			recCnt = Z.recordCount();
		if(recCnt === 0) {
			return false;
		}
		if (recno &gt;= recCnt) {
			recno = recCnt - 1;
		} else if (recno &lt; 0) {
			recno = 0;
		}
		
		if (Z._recno == recno) {
			return false;
		}
		var evt;
		if (!Z._silence) {
			Z._aborted = false;
			try {
				Z._fireDatasetEvent(jslet.data.DatasetEvent.BEFORESCROLL);
				if (Z._aborted) {
					return false;
				}
			} finally {
				Z._aborted = false;
			}
			if (!Z._lockCount) {
				evt = jslet.data.RefreshEvent.beforeScrollEvent(Z._recno);
				Z.refreshControl(evt);
			}
		}

		var preno = Z._recno;
		Z._recno = recno;
		
		if (Z._recno != preno &amp;&amp; Z._detailDatasetFields &amp;&amp; Z._detailDatasetFields.length &gt; 0) {
			var fldObj, dsDetail;
			for (var i = 0, len = Z._detailDatasetFields.length; i &lt; len; i++) {
				fldObj = Z._detailDatasetFields[i];
				dsDetail = fldObj.detailDataset();
				if (dsDetail) {
					dsDetail._initialize(true);
				}
			} //end for
		} //end if
		Z._refreshProxyField(null, Z._silenc);
		if (Z._contextRuleEnabled) {
			this.calcContextRule();
		}
		if (!Z._silence) {
			Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERSCROLL);
			if (!Z._lockCount) {
				evt = jslet.data.RefreshEvent.scrollEvent(Z._recno, preno);
				Z.refreshControl(evt);
			}
		}
		return true;
	},

<span id='jslet-data-Dataset-method-abort'>	/**
</span>	 * Abort insert/update/delete action before insert/update/delete.
	 * It's usually used with event: {@link jslet.data.DatasetEvent}
	 */
	abort: function () {
		this._aborted = true;
		return this;
	},

<span id='jslet-data-Dataset-method-aborted'>	/**
</span>	 * Get aborted status.
	 * 
	 * @return {Boolean}
	 */
	aborted: function() {
		return this._aborted;
	},
	
<span id='jslet-data-Dataset-method-_moveCursor'>	/**
</span>	 * @private
	 * 
	 * Move cursor back to startRecno(Private)
	 * 
	 * @param {Integer}startRecno - record number
	 */
	_moveCursor: function (recno) {
		var Z = this;
		Z.confirm();
		Z._gotoRecno(recno);
	},

<span id='jslet-data-Dataset-method-moveToRecord'>	/**
</span>	 * Move record cursor by record object.
	 * 
	 *     @example
	 *     var data = [{fld1: 'v1', fld2: 123}, {fld1: 'v2', fld2: 345}];
	 *     dsObj.records(data);
	 *     dsObj.moveToRecord(data[1]);
	 *     dsObj.recno(); //return 1
	 * 
	 * @param {Object} recordObj Record object.
	 * 
	 * @return {Boolean} True - Move successfully, false - otherwise. 
	 */
	moveToRecord: function (recordObj) {
		var Z = this;
		Z.confirm();
		if (!Z.hasRecord() || !recordObj) {
			return false;
		}
		jslet.Checker.test('dataset.moveToRecord#recordObj', recordObj).isObject();
		var k = Z.records().indexOf(recordObj);
		if (k &lt; 0) {
			return false;
		}
		if (Z._filteredRecnoArray) {
			k = Z._filteredRecnoArray.indexOf(k);
			if (k &lt; 0) {
				return false;
			}
		}
		Z._gotoRecno(k);
		return true;
	},

<span id='jslet-data-Dataset-method-startSilenceMove'>	/**
</span>	 * @private
	 */
	startSilenceMove: function (notLogPos) {
		var Z = this;
		var context = {};
		if (!notLogPos) {
			context.recno = Z._recno;
		} else {
			context.recno = -999;
		}

		Z._silence++;
		return context;
	},

<span id='jslet-data-Dataset-method-endSilenceMove'>	/**
</span>	 * @private
	 */
	endSilenceMove: function (context) {
		var Z = this;
		if (context &amp;&amp; context.recno != -999 &amp;&amp; context.recno != Z._recno) {
			Z._gotoRecno(context.recno);
		}
		Z._silence--;
	},

<span id='jslet-data-Dataset-property-isBof'>	/**
</span>	 * @property
	 * 
	 * Check dataset cursor at the last record
	 * 
	 * @return {Boolean}
	 */
	isBof: function () {
		return this._bof;
	},

<span id='jslet-data-Dataset-property-isEof'>	/**
</span>	 * @property
	 * 
	 * Check dataset cursor at the first record
	 * 
	 * @return {Boolean}
	 */
	isEof: function () {
		return this._eof;
	},

<span id='jslet-data-Dataset-method-first'>	/**
</span>	 * Move cursor to first record
	 */
	first: function () {
		var Z = this;
		if(!Z.hasRecord()) {
			Z._bof = Z._eof = true;
			return;
		}
		Z._moveCursor(0);
		Z._bof = Z._eof = false;
		return this;
	},

<span id='jslet-data-Dataset-method-next'>	/**
</span>	 * Move cursor to last record
	 */
	next: function () {
		var Z = this;
		var recCnt = Z.recordCount();
		if(recCnt === 0) {
			Z._bof = Z._eof = true;
			return;
		}
		if(Z._recno == recCnt - 1) {
			Z._bof = false;
			Z._eof = true;
			return;
		}
		Z._bof = Z._eof = false;
		Z._moveCursor(Z._recno + 1);
		return this;
	},

<span id='jslet-data-Dataset-method-prior'>	/**
</span>	 * Move cursor to prior record
	 */
	prior: function () {
		var Z = this;
		if(!Z.hasRecord()) {
			Z._bof = Z._eof = true;
			return;
		}
		if(Z._recno === 0) {
			Z._bof = true;
			Z._eof = false;
			return;
		}
		Z._bof = Z._eof = false;
		Z._moveCursor(Z._recno - 1);
		return this;
	},

<span id='jslet-data-Dataset-method-last'>	/**
</span>	 * Move cursor to next record
	 */
	last: function () {
		var Z = this;
		if(!Z.hasRecord()) {
			Z._bof = Z._eof = true;
			return;
		}
		Z._bof = Z._eof = false;
		Z._moveCursor(Z.recordCount() - 1);
		Z._bof = Z._eof = false;
		return this;
	},

<span id='jslet-data-Dataset-method-firstError'>	/**
</span>	 * Move cursor to the first record which exists invalid data.
	 * 
	 * @return {Boolean} If move successfully, return true, otherwise false.
	 */
	firstError: function() {
		return this._moveToError(0);
	},
	
<span id='jslet-data-Dataset-method-nextError'>	/**
</span>	 * Move cursor to the next record which exists invalid data.
	 * 
	 * @return {Boolean} If move successfully, return true, otherwise false.
	 */
	nextError: function() {
		return this._moveToError(this.recno() + 1);
	},
	
<span id='jslet-data-Dataset-method-priorError'>	/**
</span>	 * Move cursor to the prior record which exists invalid data.
	 * 
	 * @return {Boolean} If move successfully, return true, otherwise false.
	 */
	priorError: function() {
		return this._moveToError(this.recno() - 1, true);
	},
	
<span id='jslet-data-Dataset-method-lastError'>	/**
</span>	 * Move cursor to the last record which exists invalid data.
	 * 
	 * @return {Boolean} If move successfully, return true, otherwise false.
	 */
	lastError: function() {
		return this._moveToError(this.recordCount() - 1, true);
	},
	
	_moveToError: function(startRecno, reverse) {
		var Z = this, i,
			recCnt = Z.recordCount() - 1;
		if(recCnt &lt; 0) {
			return false;
		}
		if(!reverse) {
			if(startRecno &lt; 0) {
				startRecno = 0;
			}
			for(i = startRecno; i &lt;= recCnt; i++) {
				if(Z.existRecordError(i)) {
					Z._moveCursor(i);
					return true;
				}
			}
		} else {
			if(startRecno &gt; recCnt) {
				startRecno = recCnt;
			}
			for(i = startRecno; i &gt;= 0; i--) {
				if(Z.existRecordError(i)) {
					Z._moveCursor(i);
					return true;
				}
			}
		}
		return false;
	},
	
<span id='jslet-data-Dataset-method-checkStatusByCancel'>	/**
</span>	 * @private
	 * Check dataset status and cancel dataset 
	 */
	checkStatusByCancel: function () {
		if (this._status != jslet.data.DataSetStatus.BROWSE) {
			this.cancel();
		}
	},

<span id='jslet-data-Dataset-method-insertChild'>	/**
</span>	 * Insert child record by parentId, and move cursor to the newly record.
	 * 
	 *     @example
	 *     var parentId = dsObj.keyValue();
	 *     dsObj.insertChild(parentId);
	 *     dsObj.setFieldValue('fld1', 'test');
	 *     dsObj.confirm();
	 * 
	 * @param {Object} parentId (optional) Key value of parent record, it not apply, use current record key value instead.
	 *  
	 * @return {this}
	 */
	insertChild: function (parentId) {
		var Z = this;
		if (!Z._parentField || !Z.keyField()) {
			//Dataset properties: [parentField] and [keyField] not set, use insertRecord() instead!
			throw new Error(jsletlocale.Dataset.parentFieldNotSet);
		}

		if (!Z.hasRecord()) {
			Z.innerInsert();
			return this;
		}

		var context = Z.startSilenceMove(true);
		try {
			Z.expanded(true);
			if (parentId) {
				if (!Z.findByKey(parentId)) {
					return this;
				}
			} else {
				parentId = Z.keyValue();
			}

			var pfldname = Z.parentField(), 
				parentParentId = Z.getFieldValue(pfldname);
			while (true) {
				Z.next();
				if (Z.isEof()) {
					break;
				}
				if (parentParentId == Z.getFieldValue(pfldname)) {
					Z.prior();
					break;
				}
			}
		} finally {
			Z.endSilenceMove(context);
		}

		Z.innerInsert(function (newRec) {
			newRec[Z._parentField] = parentId;
		});
		return this;
	},

<span id='jslet-data-Dataset-method-insertSibling'>	/**
</span>	 * Insert sibling record of current record, and move cursor to the newly record.
	 * 
	 *     @example
	 *     dsObj.insertSibling();
	 *     dsObj.setFieldValue('fld1', 'test');
	 *     dsObj.confirm();
	 *     
	 * @return {this}
	 */
	insertSibling: function () {
		var Z = this;
		if (!Z._parentField || !Z._keyField) {
			//Dataset properties: [parentField] and [keyField] not set, use insertRecord() instead!
			throw new Error(jsletlocale.Dataset.parentFieldNotSet);
		}

		if (!Z.hasRecord()) {
			Z.innerInsert();
			return this;
		}

		var parentId = Z.getFieldValue(Z.parentField()),
			context = Z.startSilenceMove(true),
			found = false,
			parentKeys = [],
			currPKey, 
			prePKey = Z.keyValue(),
			lastPKey = prePKey;
		try {
			Z.next();
			while (!Z.isEof()) {
				currPKey = Z.parentValue();
				if(currPKey == prePKey) {
					parentKeys.push(prePKey);
					lastPKey = prePKey;
				} else {
					if(lastPKey != currPKey) {
						if(parentKeys.indexOf(currPKey) &lt; 0) {
							Z.prior();
							found = true;
							break;
						}
					}
				}
				prePKey = currPKey;
				Z.next();
			}
			if (!found) {
				Z.last();
			}
		} finally {
			Z.endSilenceMove(context);
		}

		Z.innerInsert(function (newRec) {
			newRec[Z._parentField] = parentId;
		});
		return this;
	},

<span id='jslet-data-Dataset-method-insertRecord'>	/**
</span>	 * Insert record after current record, and move cursor to the newly record.
	 * 
	 *     @example
	 *     dsObj.insertRecord();
	 *     dsObj.setFieldValue('fld1', 'test');
	 *     dsObj.confirm();
	 * 
	 * @return {this}
	 */
	insertRecord: function () {
		this.innerInsert();
		return this;
	},

<span id='jslet-data-Dataset-method-appendRecord'>	/**
</span>	 * Add record after last record, and move cursor to the newly record.
	 * 
	 *     @example
	 *     dsObj.appendRecord();
	 *     dsObj.setFieldValue('fld1', 'test');
	 *     dsObj.confirm();
	 * 
	 * @return {this}
	 */
	appendRecord: function () {
		var Z = this;

		Z._silence++;
		try {
			Z.last();
		} finally {
			Z._silence--;
		}
		Z.insertRecord();
		return this;
	},

<span id='jslet-data-Dataset-method-status'>	/**
</span>	 * @private
	 */
	status: function(status) {
		if(status === undefined) {
			return this._status;
		}
		this._status = status;
		return this;
	},
	
<span id='jslet-data-Dataset-property-expanded'>	/**
</span>	 * @property
	 * 
	 * Set or get the current record is expanded or not. Example:
	 * 
	 *     @example
	 *     dsObj.expanded(true); //Set property, return this.
	 *     var propValue = dsObj.expanded(); //Get property value.
	 * 
	 * @param {Boolean | undefined} expanded True - expanded, false - collapsed.
	 * 
	 * @return {this | Boolean}
	 */
	expanded: function(expanded) {
		return this.expandedByRecno(this.recno(), expanded);
	},
	
<span id='jslet-data-Dataset-property-expandedByRecno'>	/**
</span>	 * @property
	 * 
	 * Set or get the specified record is expanded or not. Example:
	 * 
	 *     @example
	 *     var recno = dsObj.recno();
	 *     dsObj.expandedByRecno(recno, true); //Set property, return this.
	 *     var propValue = dsObj.expandedByRecno(recno); //Get property value.
	 * 
	 * @param {Integer | undefined} recno Record number.
	 * @param {this | Boolean} True - expanded, false - collapsed.
	 * 
	 * @return {this | Boolean}
	 */
	expandedByRecno: function(recno, expanded) {
		jslet.Checker.test('dataset.expandedByRecno', recno).required().isNumber();
		var record = this.getRecord(recno);
		var recInfo = jslet.data.getRecInfo(record);
		if(expanded === undefined) {
			var result = recInfo &amp;&amp; recInfo.expanded;
			return result? true: false;
		}
		if(recInfo === null) {
			return this;
		}
		recInfo.expanded = expanded;
		return this;
	},
	
<span id='jslet-data-Dataset-property-insertedByRecno'>	/**
</span>	 * @property
	 * 
	 * Set or get the specified record is inserted or not. Example:
	 * 
	 *     @example
	 *     var recno = dsObj.recno();
	 *     dsObj.insertedByRecno(recno, true); //Set property, return this.
	 *     var propValue = dsObj.insertedByRecno(recno); //Get property value.
	 * 
	 * @param {Integer} recno Record number.
	 * @param {Boolean | undefined} inserted True - inserted, false - not changed.
	 * 
	 * @return {this | Boolean}
	 */
	insertedByRecno: function(recno, inserted) {
		if(inserted === undefined) {
			return this.changedStatusByRecno(recno) === jslet.data.DataSetStatus.INSERT;
		}
		var recObj = this.getRecord(recno);
		if(inserted) {
			this.changedStatusByRecno(recno, jslet.data.DataSetStatus.INSERT);
			this._changeLog.log(recObj);
		} else {
			this.changedStatusByRecno(recno, jslet.data.DataSetStatus.BROWSE);
			this._changeLog.unlog(recObj);
		}
		return this;
	},
	
<span id='jslet-data-Dataset-property-updatedByRecno'>	/**
</span>	 * @property
	 * 
	 * Get or set the specified record is updated or not. Example:
	 * 
	 *     @example
	 *     var recno = dsObj.recno();
	 *     dsObj.updatedByRecno(recno, true); //Set property, return this.
	 *     var propValue = dsObj.updatedByRecno(recno); //Get property value.
	 * 
	 * @param {Integer} recno Record number.
	 * @param {Boolean | undefined} updated True - updated, false - not changed.
	 * 
	 * @return {Boolean | this}
	 */
	updatedByRecno: function(recno, updated) {
		if(updated === undefined) {
			return this.changedStatusByRecno(recno) === jslet.data.DataSetStatus.UPDATE;
		}
		var recObj = this.getRecord(recno);
		if(updated) {
			this.changedStatusByRecno(recno, jslet.data.DataSetStatus.UPDATE);
			this._changeLog.log(recObj);
		} else {
			this.changedStatusByRecno(recno, jslet.data.DataSetStatus.BROWSE);
			this._changeLog.unlog(recObj);
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-changedStatus'>	/**
</span>	 * @private
	 */
	changedStatus: function(status) {
		if(status === undefined) {
			return this.changedStatusByRecno(this._recno, status);
		}
		this.changedStatusByRecno(this._recno, status);
		return this;
	},
	
<span id='jslet-data-Dataset-method-changedStatusByRecno'>	/**
</span>	 * @private
	 */
	changedStatusByRecno: function(recno, status) {
		var Z = this, record, recInfo;
		if(status === undefined) {
			record = Z.getRecord(recno);
			if(!record) {
				return null;
			}
			recInfo = jslet.data.getRecInfo(record);
			if(!recInfo) {
				return jslet.data.DataSetStatus.BROWSE;
			}
			return recInfo.status;
		}
		if(!Z._logChanges) {
			return;
		}
		record = Z.getRecord(recno);
		if(!record) {
			return null;
		}
		recInfo = jslet.data.getRecInfo(record);
		if(status === jslet.data.DataSetStatus.DELETE) {
			recInfo.status = status;
			return;
		}
		var	oldStatus = recInfo.status;
		if(oldStatus === jslet.data.DataSetStatus.INSERT) {
			return;
		}
		if(oldStatus != status) {
			recInfo.status = status;
			if (Z._contextRuleEnabled) {
				Z.calcContextRule();
			}
		}
	},
	
<span id='jslet-data-Dataset-method-innerInsert'>	/**
</span>	 * @private
	 */
	innerInsert: function (beforeInsertFn) {
		var Z = this;
		Z.confirm();

		Z.selection.removeAll();
		var dsMaster = Z.masterDataset();
		if (dsMaster) {
			if (!dsMaster.hasRecord()) {
				dsMaster.appendRecord();
			} else {
				dsMaster.editRecord();
			}
		}

		Z._aborted = false;
		try {
			Z._fireDatasetEvent(jslet.data.DatasetEvent.BEFOREINSERT);
			if (Z._aborted) {
				return;
			}
		} finally {
			Z._aborted = false;
		}

		var records = Z.records();
		if (records === null) {
			records = [];
			if(Z._masterField) { //Detail dataset doesn't have its own records.
				Z.masterDataset().setFieldValue(Z._masterField, records);
			} else {
				Z._records = records;
			}
		}
		var preRecno = Z.recno(), k;
		if (Z.hasRecord()) {
			k = records.indexOf(this.getRecord()) + 1;
		} else {
			k = 0;
		}

		var newRecord = {};
		records.splice(k, 0, newRecord);

		if (Z._filteredRecnoArray &amp;&amp; Z._filteredRecnoArray.length &gt; 0) {
			for (var i = Z._filteredRecnoArray.length - 1; i &gt;= 0; i--) {
				if (Z._filteredRecnoArray[i] &lt; k) {
					Z._filteredRecnoArray.splice(i + 1, 0, k);
					Z._recno = k;
					break;
				}
				Z._filteredRecnoArray[i] += 1;
			}
		} else {
			if(Z._filteredRecnoArray) {
				Z._filteredRecnoArray[0] = k;
			}
			Z._recno = k;
		}
		
		Z.status(jslet.data.DataSetStatus.INSERT);
		Z.changedStatus(jslet.data.DataSetStatus.INSERT);
		Z._lockCount++;
		try {
			Z._calcDefaultValue();
			if (beforeInsertFn) {
				beforeInsertFn(newRecord);
			}
	
			//calc other fields' range to use context rule
			if (Z._contextRuleEnabled) {
				Z.calcContextRule();
			}
	
			Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERINSERT);
			Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERSCROLL);
		} finally {
			Z._lockCount--;
		}
		var evt = jslet.data.RefreshEvent.insertEvent(preRecno, Z.recno(), Z._recno &lt; Z.recordCount() - 1);
		Z.refreshControl(evt);
	},

<span id='jslet-data-Dataset-method-insertDataset'>	/**
</span>	 * Insert all records of source dataset into current dataset; &lt;br /&gt;
	 * Source dataset's structure must be same as current dataset.
	 * 
	 * @param {jslet.data.Dataset} srcDataset Source dataset.
	 * 
	 * @return {this}
	 */
	insertDataset: function (srcDataset) {
		var Z = this,
			oldFiltered = Z.filtered(),
			thisContext = Z.startSilenceMove(true),
			srcContext = srcDataset.startSilenceMove(true), rec;
		try {
			Z.filtered(false);
			srcDataset.first();
			while (!srcDataset.isEof()) {
				Z.insertRecord();
				Z.cloneRecord(srcDataset.getRecord(), Z.getRecord());
				Z.confirm();
				srcDataset.next();
			}
		} finally {
			srcDataset.endSilenceMove(srcContext);
			Z.filtered(oldFiltered);
			Z.endSilenceMove(thisContext);
		}
		return this;
	},

<span id='jslet-data-Dataset-method-appendDataset'>	/**
</span>	 * Append all records of source dataset into current dataset; &lt;br /&gt;
	 * Source dataset's structure must be same as current dataset .
	 * 
	 * @param {jslet.data.Dataset} srcDataset Source dataset.
	 * 
	 * @return {this}
	 */
	appendDataset: function (srcDataset) {
		var Z = this;
		Z._silence++;
		try {
			Z.last();
		} finally {
			Z._silence--;
		}
		Z.insertDataset(srcDataset);
		return this;
	},

<span id='jslet-data-Dataset-method-batchAppendRecords'>	/**
</span>	 * Append records into dataset.
	 * 
	 * @param {Object[]} records An array of object which need to append to dataset.
	 * @param {Boolean} replaceExists True - replace the record if it exists, false - skip to append if it exists.
	 *  
	 * @return {this}
	 */
	batchAppendRecords: function(records, replaceExists) {
		jslet.Checker.test('dataset.records', records).required().isArray();
		var Z = this;
		Z.confirm();
		
		Z.selection.removeAll();
		Z.disableControls();
		try{
			var keyField = Z.keyField(), rec, found,
				keyValue;
			for(var i = 0, len = records.length; i &lt; len; i++) {
				rec = records[i];
				found = false;
				if(keyField) {
					keyValue = rec[keyField];
					if(keyValue &amp;&amp; Z.findByKey(keyValue)) {
						found = true;
					}
				}
				if(found) {
					if(replaceExists) {
						Z.editRecord();
						Z.cloneRecord(rec, Z.getRecord());
						Z.confirm();
					} else {
						continue;
					}
				} else {
					Z.appendRecord();
					Z.cloneRecord(rec, Z.getRecord());
					Z.confirm();
				}
			}
		} finally {
			Z.enableControls();
			Z.refreshControl(jslet.data.RefreshEvent._updateAllEvent);
			Z.refreshLookupHostDataset();
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-_calcDefaultValue'>	/**
</span>	 * @private
	 * Calculate default value.
	 */
	_calcDefaultValue: function () {
		var Z = this, fldObj, expr, value, fldName;
		for (var i = 0, fldcnt = Z._normalFields.length; i &lt; fldcnt; i++) {
			fldObj = Z._normalFields[i];
			fldName = fldObj.name();
			if (fldObj.getType() == jslet.data.DataType.DATASET) {
				continue;
			}
			
			if(Z._valueFollowEnabled &amp;&amp; fldObj.valueFollow() &amp;&amp; Z._followedValues) {
				var fValue = Z._followedValues[fldName];
				if(fValue !== null &amp;&amp; fValue !== undefined) {
					fldObj.setValue(fValue);
					continue;
				}
			}
			value = fldObj.defaultValue();
			if (value === undefined || value === null || value === '') {
				expr = fldObj.defaultExpr();
				if (!expr) {
					continue;
				}
				value = window.eval(expr);
			} else {
				if(fldObj.getType() === jslet.data.DataType.NUMBER) {
					value = fldObj.scale() &gt; 0 ? parseFloat(value): parseInt(value);
				}
			}
			var valueStyle = fldObj.valueStyle();
			if(value &amp;&amp; jslet.isDate(value)) {
				value = new Date(value.getTime());
			}
			if(valueStyle == jslet.data.FieldValueStyle.BETWEEN) {
				if(value) {
					value = [value, value];
				} else {
					value = [null, null];
				}
			} else if(valueStyle == jslet.data.FieldValueStyle.MULTIPLE) {
				value = [value];
			}
			Z.setFieldValue(fldName, value);		
		}
	},

<span id='jslet-data-Dataset-method-checkAggregated'>	/**
</span>	 * @private
	 * Calculate default value.
	 */
	checkAggregated: function(fldName) {
		var Z = this,
			aggrFields = Z._aggregatedFields;
		if(!aggrFields || aggrFields.length === 0) {
			return false;
		}
		if(!fldName) {
			return true;
		}
		var fldObj;
		for(var i = 0, len = aggrFields.length; i &lt; len; i++) {
			if(aggrFields[i].name() === fldName) {
				return true;
			}
		}
		return false;
	},
	
<span id='jslet-data-Dataset-method-disableAggregating'>	/**
</span>	 * @private
	 * 
	 * Disable aggregate value. It's used for improving performance for batch operating, especially for huge data.
	 */
	disableAggregating: function() {
		this._aggregatingCount++;
		return this;
	},
	
<span id='jslet-data-Dataset-method-enableAggregating'>	/**
</span>	 * @private
	 * 
	 * Enable aggregate value.
	 */
	enableAggregating: function() {
		var Z = this;
		if(Z._aggregatingCount &gt; 0) {
			Z._aggregatingCount--;
			if(Z._aggregatingCount === 0) {
				Z._calcAggregatedValueDebounce.call(Z);
			}
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-calcAggregatedValue'>	/**
</span>	 * @private
	 * 
	 * Calculate aggregated value.
	 */
	calcAggregatedValue: function(fldName) {
		var Z = this;
		
		if(Z._aggregatingCount &gt; 0 || !Z.checkAggregated(fldName)) {
			return;
		}
		var aggrFields = Z._aggregatedFields,
			fldObj, aggregatedBy,
			arrAggregateBy = {},
			aggregatedValues = null,
			notCalcFields = [],
			isNum, i, len;
		for(i = 0, len = aggrFields.length; i &lt; len; i++) {
			fldObj = aggrFields[i];
			aggregatedBy = fldObj.aggregatedBy();
			isNum = fldObj.getType() === jslet.data.DataType.NUMBER;
			if((!isNum || isNum &amp;&amp; fldObj.lookup()) &amp;&amp; !aggregatedBy) {
				if(!aggregatedValues) {
					aggregatedValues = {};
				}
				fldName = fldObj.name();
				aggregatedValues[fldName] = {count: Z.recordCount(), sum: 0};
				notCalcFields.push(fldName);
			}
			if(aggregatedBy &amp;&amp; !arrAggregateBy[aggregatedBy]) {
				arrAggregateBy[aggregatedBy] = {aggregatedBy: aggregatedBy, values: {}, exists: false};
			}
		}
		if(aggrFields.length === notCalcFields.length) {
			Z.aggregatedValues(aggregatedValues);			
			return;
		}
		if(!aggregatedValues) {
			aggregatedValues = {};
		}
		
		function getAggregateByValue(aggregatedBy) {
			if(aggregatedBy.indexOf(',') &lt; 0) {
				return Z.getFieldValue(aggregatedBy);
			}
			var fieldNames = aggregatedBy.split(',');
			var values = [];
			for(var i = 0, len = fieldNames.length; i &lt; len; i++) {
				values.push(Z.getFieldValue(fieldNames[i]));
			}
			return values.join(',');
		}
		
		function updateAggrByValues(arrAggregateBy) {
			var aggrByObj, 
				aggrByValue,
				arrAggrByValues;
			for(var name in arrAggregateBy) {
				aggrByObj = arrAggregateBy[name];
				arrAggrByValues = aggrByObj.values;
				aggrByValue = getAggregateByValue(aggrByObj.aggregatedBy);
				if(arrAggrByValues[aggrByValue] === undefined) {
					arrAggrByValues[aggrByValue] = null;
					aggrByObj.exists = false;
				} else {
					aggrByObj.exists = true;
				}
			}
		}
		
		function existAggrBy(arrAggregateBy, aggregatedBy) {
			var aggrByObj;
			for(var name in arrAggregateBy) {
				aggrByObj = arrAggregateBy[name];
				return aggrByObj.exists;
			}
			console.warn('Not found aggregatedBy value!');
			return false;
		}
		
		var oldRecno = Z.recnoSilence(),
			fldCnt = aggrFields.length, 
			value, totalValue,
			aggregatedValueObj;
		try {
			for(var k = 0, recCnt = Z.recordCount(); k &lt; recCnt; k++) {
				Z.recnoSilence(k);
				updateAggrByValues(arrAggregateBy);
				
				for(i = 0; i &lt; fldCnt; i++) {
					fldObj = aggrFields[i];
					fldName = fldObj.name();
					if(notCalcFields.indexOf(fldName) &gt;= 0) {
						continue;
					}
					aggregatedBy = fldObj.aggregatedBy();
					if(aggregatedBy &amp;&amp; existAggrBy(arrAggregateBy, aggregatedBy)) {
						continue;
					}
					aggregatedValueObj = aggregatedValues[fldName];
					if(!aggregatedValueObj) {
						aggregatedValueObj = {count: 0, sum: 0};
						aggregatedValues[fldName] = aggregatedValueObj; 
					}
					aggregatedValueObj.count = aggregatedValueObj.count + 1;
					if(fldObj.getType() === jslet.data.DataType.NUMBER) {
						value = Z.getFieldValue(fldName) || 0;
						if(jslet.isString(value)) {
							//Invalid value: [{1}] for NUMBER field: [{0}]!
							throw new Error(jslet.formatMessage(jsletlocale.Dataset.invalidNumberFieldValue, [fldName, value]));
						}
						aggregatedValueObj.sum = aggregatedValueObj.sum + value;
					}
				} //end for i
			} //end for k
		} finally {
			Z.recnoSilence(oldRecno);
		}
		var scale;
		for(i = 0; i &lt; fldCnt; i++) {
			fldObj = aggrFields[i];
			fldName = fldObj.name();
			scale = fldObj.scale() || 0;
			aggregatedValueObj = aggregatedValues[fldName];
			if(!aggregatedValueObj ) {
				aggregatedValueObj = {count: 0, sum: 0};
				aggregatedValues[fldName] = aggregatedValueObj;
			}
			var sumValue = aggregatedValueObj.sum;
			if(sumValue) {
				var pow = Math.pow(10, scale);
				sumValue = Math.round(sumValue * pow) / pow;
				aggregatedValueObj.sum = sumValue;
			}
		} //end for i
		Z.aggregatedValues(aggregatedValues);			
	},
	
<span id='jslet-data-Dataset-method-aggregatedValues'>	/**
</span>	 * Get aggregated values. Example:
	 * 
	 *     @example
	 *     var aggregated = dsObj.aggregatedValues();
	 *     var fldName = 'fld1';
	 *     var fldAggregated = aggregated[fldName];
	 *     var sum = fldAggregated.sum;
	 *     var count = fldAggregated.count;
	 * 
	 * @return {Object[]} Aggregated values
	 */
	aggregatedValues: function(aggregatedValues) {
		var Z = this;
		if(aggregatedValues === undefined) {
			return Z._aggregatedValues;
		}
		Z._aggregatedValues = aggregatedValues;
		if(!Z._aggregatedValues &amp;&amp; !aggregatedValues) {
			return;
		}

		var evt = jslet.data.RefreshEvent.aggregatedEvent();
		Z.refreshControl(evt);
		return this;
	},
	
<span id='jslet-data-Dataset-method-getRecord'>	/**
</span>	 * Get record object by record number.
	 * 
	 * @param {Integer} recno (optional) Record number, if not applied, get current record instead.
	 * 
	 * @return {Object} Dataset record.
	 */
	getRecord: function (recno) {
		var Z = this, k;
		if (recno === undefined || recno === null) {
			recno = Z._recno &gt;= 0 ? Z._recno : 0;
		} else {
			if (recno &lt; 0 || recno &gt;= Z.recordCount()) {
				return null;
			}
		}
		if(!Z.hasData()) {
			return null;
		}
		var records = Z.records();
		//Used to convert field value for performance purpose. 
		if(Z._ignoreFilter) {
			return records[Z._ignoreFilterRecno || 0];
		}
		
		if (Z.recordCount() === 0) {
			return null;
		}
		
		if (Z._filteredRecnoArray) {
			k = Z._filteredRecnoArray[recno];
		} else {
			k = recno;
		}

		return records[k];
	},

<span id='jslet-data-Dataset-method-setRecord'>	/**
</span>	 * Set field values with a plan object.
	 *  
	 *     @example
	 *     var recObj = {fld1: 'test', fld2: 234};
	 *     dsObj.setRecord(recObj);
	 *     dsObj.confirm();
	 *     dsObj.getFieldValue('fld1'); //return 'test'
	 *     
	 * @param {Object} recObj A plan object which contains field values.
	 * @param {Integer} recno (optional) Record number.
	 * 
	 * @return {this}
	 */
	setRecord: function(recObj, recno) {
		if(!recObj) {
			return this;
		}
		var Z = this;
		Z.disableControls();
		try {
			if(recno) {
				Z.recno(recno);
			}
			for(var name in recObj) {
				if(name == '_jl_') {
					continue;
				}
				Z.setFieldValue(name, recObj[name]);
			}
		} finally {
			Z.enableControls();
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-getRelativeRecord'>	/**
</span>	 * @private
	 */
	getRelativeRecord: function (delta) {
		return this.getRecord(this._recno + delta);
	},

<span id='jslet-data-Dataset-method-isSameAsPrevious'>	/**
</span>	 * @private
	 */
	isSameAsPrevious: function (fldName) {
		var Z = this,
			preRec = Z.getRelativeRecord(-1);
		if (!preRec) {
			return false;
		}
		var currRec = Z.getRecord(),
			preValue = Z.getFieldValueByRecord(preRec, fldName),
			currValue = Z.getFieldValueByRecord(currRec, fldName),
			isSame = false;
		
		if(!preValue &amp;&amp; preValue !== 0 &amp;&amp; preValue !== false &amp;&amp; 
				!currValue &amp;&amp; currValue !== 0 &amp;&amp; currValue !== false) {
			isSame = false;
		} else if(preValue &amp;&amp; currValue) {
			if(jslet.isDate(preValue)) { //Date time comparing
				isSame = (preValue.getTime() === currValue.getTime());
			} else {
				isSame = (preValue === currValue);
			}
		}
		if(!isSame) {
			return isSame;
		}
		var	fldObj = Z.getField(fldName),
			mergeSameBy = fldObj.mergeSameBy();
		if(mergeSameBy) {
			var arrFlds = mergeSameBy.split(','), groupFldName;
			for(var i = 0, len = arrFlds.length; i &lt; len; i++) {
				groupFldName = jslet.trim(arrFlds[i]);
				if(preRec[groupFldName] != currRec[groupFldName]) {
					return false;
				}
			}
		}
		return isSame;
	},

<span id='jslet-data-Dataset-method-hasParent'>	/**
</span>	 * Check wheather the current record has parent record or not.
	 * 
	 * @return {Boolean} True - has parent record. 
	 */
	hasParent: function() {
		var Z = this,
			pFldName = Z.parentField();
		if(!pFldName || Z.recno() === 0) {
			return false;
		}
		var recno = Z.recno() - 1;
		for(var k = recno; k &gt;= 0; k--) {
			var pKeyValue = Z.getFieldValue(pFldName),
				prevRec = this.getRelativeRecord(k - recno),
				keyValue = this.getFieldValueByRecord(prevRec, Z.keyField());
			
			if(jslet.compareValue(pKeyValue, keyValue) === 0) {
				return true;
			}
			var prePKeyValue = this.getFieldValueByRecord(prevRec, Z.parentField());
			if(jslet.compareValue(pKeyValue, prePKeyValue) !== 0) {
				return false;
			}
		}
		return false;
	},
	
<span id='jslet-data-Dataset-method-hasChildren'>	/**
</span>	 * Check the current record has child records or not
	 * 
	 * @return {Boolean} True - has child records.
	 */
	hasChildren: function () {
		var Z = this;
		if (!Z._parentField) {
			return false;
		}
		if(Z._recno &lt; Z.recordCount() - 1) {
			if (Z.parentValue(Z._recno + 1) === Z.keyValue()) {
				return true;
			}
		}
		return false;
	},
	
<span id='jslet-data-Dataset-method-iterateChildren'>	/** 
</span>	* Iterate the child records of current record, and run the specified callback function. Example: 
	* 
	*     @example
	*     dataset.iterateChildren(function(isDirectChild){
	* 	    var fldValue = this.getFieldValue('xxx');
	* 	    this.setFieldValue('xxx', fldValue);
	*     }); 
	* 
	* @param {Function} callBackFn Callback function.
	* @param {Boolean} callBackFn.isDirectChild True - is direct child, false - otherwise.
	* @param {Boolean} callBackFn.return Identify continue iterating or not, true - break iterating, false -continue iterating.
	* 
	* @return {this}
	*/ 
	iterateChildren: function(callBackFn) {
		var Z = this;
		if (!Z._parentField) {
			return this;
		}
		var context = Z.startSilenceMove(),
			preKeyValue = Z.keyValue(),
			rootValue = preKeyValue,
			arrPValues = [];
		try {
			Z.next();
			var keyValue, pValue, isExist;
			while (!Z.isEof()) {
				pValue = Z.parentValue();
				isExist = (arrPValues.indexOf(pValue) &gt;= 0);
				if(jslet.compareValue(pValue, preKeyValue) === 0 &amp;&amp; !isExist) {
					arrPValues.push(preKeyValue);
					isExist = true;
				}
				if (!isExist) {
					return this;
				}
				if(callBackFn) {
					var breakIterator = callBackFn.call(Z, jslet.compareValue(pValue, rootValue) === 0);
					if(breakIterator) {
						break;
					}
				}
				preKeyValue = Z.keyValue();
				Z.next();
			}
		} finally {
			Z.endSilenceMove(context);
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-editRecord'>	/**
</span>	 * Update record and send dataset to update status. &lt;br /&gt;
	 * You can use cancel() or confirm() method to return browse status.
	 * 
	 *     @example
	 *     dsObj.editRecord();
	 *     dsObj.setFieldValue('fld1', 123);
	 *     dsObj.confirm();
	 * 
	 * @fires BEFOREUPDATE
	 * @fires AFTERUPDATE
	 * 
	 * @return {this}
	 */
	editRecord: function () {
		var Z = this;
		if (Z._status == jslet.data.DataSetStatus.UPDATE ||
			Z._status == jslet.data.DataSetStatus.INSERT) {
			return this;
		}

		Z.selection.removeAll();
		if (!Z.hasRecord()) {
			Z.insertRecord();
		} else {
			Z._aborted = false;
			try {
				Z._fireDatasetEvent(jslet.data.DatasetEvent.BEFOREUPDATE);
				if (Z._aborted) { 
					return this;
				}
			} finally {
				Z._aborted = false;
			}

			Z._modiObject = {};
			jQuery.extend(Z._modiObject, Z.getRecord());
			var dsMaster = Z.masterDataset();
			if (dsMaster) {
				dsMaster.editRecord();
			}

			Z.status(jslet.data.DataSetStatus.UPDATE);
			Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERUPDATE);
		}
		return this;
	},

<span id='jslet-data-Dataset-method-deleteRecord'>	/**
</span>	 * Delete curent record.
	 * 
	 * @fires BEFOREUPDATE
	 * @fires AFTERUPDATE
	 * 
	 * @return {Boolean} Identify whether the record is deleted. If delete the new record which is not submit to server, it returns false. 
	 */
	deleteRecord: function () {
		var Z = this,
			recCnt = Z.recordCount();
		if (recCnt === 0 || Z.changedStatus() === jslet.data.DataSetStatus.DELETE) {
			return false;
		}
		Z._aborted = false;
		try {
			Z._fireDatasetEvent(jslet.data.DatasetEvent.BEFOREDELETE);
			if (Z._aborted) {
				return false;
			}
		} finally {
			Z._aborted = false;
		}
		
		Z.selection.removeAll();
		if (Z._status === jslet.data.DataSetStatus.INSERT) {
			Z.cancel();
			return false;
		}

		Z._silence++;
		try {
			Z.checkStatusByCancel();
		} finally {
			Z._silence--;
		}

		if (Z.hasChildren()) {
			jslet.showInfo(jsletlocale.Dataset.cannotDelParent);
			return false;
		}

		var preRecno = Z.recno(), 
			isLast = preRecno == (recCnt - 1), 
			k = Z._recno,
			deleted = false;
		if(Z.changedStatus() === jslet.data.DataSetStatus.INSERT) {
			Z._changeLog.unlog();
		} else {
			Z.changedStatus(jslet.data.DataSetStatus.DELETE);
			Z._changeLog.log();
			deleted = true;
		}
		Z.records().splice(k, 1);
		Z._refreshInnerRecno();
		
		var dsMaster = Z.masterDataset();
		if (dsMaster) {
			dsMaster.editRecord();
		}

		Z.status(jslet.data.DataSetStatus.BROWSE);
		
		if (isLast) {
			Z._silence++;
			try {
				Z.prior();
			} finally {
				Z._silence--;
			}
		} else {
			Z._refreshProxyField();
			if (Z._contextRuleEnabled) {
				this.calcContextRule();
			}
		}
		Z._calcAggregatedValueDebounce.call(Z);
		var evt = jslet.data.RefreshEvent.deleteEvent(preRecno);
		Z.refreshControl(evt);
		
		Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERSCROLL);	
		Z.refreshLookupHostDataset();
		var detailFields = Z._detailDatasetFields;
		if(detailFields) {
			var dtlFldObj, dsDetail;
			for(var i = 0, len = detailFields.length; i &lt; len; i++) {
				dtlFldObj = detailFields[i];
				dsDetail = dtlFldObj.detailDataset();
				if(dsDetail) {
					dsDetail.refreshControl();
				}
			}
		}
		if (Z.isBof() &amp;&amp; Z.isEof()) {
			return deleted;
		}
		evt = jslet.data.RefreshEvent.scrollEvent(Z._recno);
		Z.refreshControl(evt);
		return deleted;
	},

<span id='jslet-data-Dataset-method-deleteSelected'>	/**
</span>	 * Delete all selected records.
	 * 
	 * @return {this}
	 */
	deleteSelected: function() {
		var Z = this, 
			records = Z.selectedRecords(),
			recObj;
		Z.disableControls();
		try {
			for(var i = records.length - 1; i &gt;= 0; i--) {
				recObj = records[i];
				Z.moveToRecord(recObj);
				Z.deleteRecord();
			}
		} finally {
			Z.enableControls();
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-validateDataset'>	/**
</span>	 * Validate the dataset. Sometimes, the dataset's records is inputted outerside dataset object, then dataset can not validate data automatically.
	 * In this case, use this method to validate data manually. Example:
	 * 
	 *     @example
	 *     var records = [{field1: 'value1', field2: 123}, {field1: 'value2', field2: null}];
	 *     var dsObj.records(records);
	 *     dsObj.validateDataset(); //Validate all fields
	 *     dsObj.validateDataset(['field1']); //include fields: field1
	 *     dsObj.validateDataset(null, ['field1']);  exclude fields: field2
	 * 
	 * @param {String[]} includeFields The fields which need to be validated.
	 * @param {String[]} excludeFields The fields which don't need to be validated.
	 */
	validateDataset: function(includeFields, excludeFields) {
		var Z = this;
		Z.iterate(function() {
			Z.validateRecord(includeFields, excludeFields);
		});
		return this;
	},
	
<span id='jslet-data-Dataset-method-validateRecord'>	/**
</span>	 * Validate the current record. It's almost used in method: validateDataset.
	 * 
	 * @param {String[]} includeFields The fields which need to be validated.
	 * @param {String[]} excludeFields The fields which don't need to be validated.
	 */
	validateRecord: function(includeFields, excludeFields) {
		var Z = this;
		if (Z.recordCount() === 0) {
			return this;
		}
		
		var fldObj, fldName, fldValue, invalidMsg;
		for (var i = 0, cnt = Z._normalFields.length; i &lt; cnt; i++) {
			fldObj = Z._normalFields[i];
			fldName = fldObj.name();
			if(excludeFields &amp;&amp; excludeFields.indexOf(fldName) &gt;= 0 || 
			   includeFields &amp;&amp; includeFields.indexOf(fldName) &lt; 0) {
				continue;
			}
			invalidMsg = null;
			fldValue = Z.getFieldValue(fldName);
			invalidMsg = Z._fieldValidator.checkValue(fldObj, Z.getFieldValue(fldName));
			if (invalidMsg) {
				Z.setFieldError(fldName, invalidMsg);
			} else {
				Z.setFieldError(fldName, null);
			}
		} //end for i
		if(Z._masterDataset &amp;&amp; Z._masterField) {
			var masterDsObj = jslet.data.getDataset(Z._masterDataset),
				masterFldObj = masterDsObj.getField(Z._masterField);
			if(Z.existRecordError()) {
				//'Detail Dataset: {0} has error data!'
				masterDsObj.addFieldError(Z._masterField, jslet.formatMessage(jsletlocale.Dataset.detailDsHasError, [Z.name()]));
			} else {
				masterDsObj.addFieldError(Z._masterField, null);
			}
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-_innerValidateData'>	/**
</span>	 * @private
	 */
	_innerValidateData: function (includeFields, excludeFields) {
		var Z = this;
		if (Z._status == jslet.data.DataSetStatus.BROWSE || Z.recordCount() === 0) {
			return;
		}
		
		var fldObj, fldName, fldValue, invalidMsg;
		for (var i = 0, cnt = Z._normalFields.length; i &lt; cnt; i++) {
			fldObj = Z._normalFields[i];
			fldName = fldObj.name();
			if(Z.existFieldError(fldName) || !fldObj.visible() || fldObj.disabled() || fldObj.readOnly() || excludeFields &amp;&amp; excludeFields.indexOf(fldName) &gt;= 0 || 
				includeFields &amp;&amp; includeFields.indexOf(fldName) &lt; 0 ) {
				continue;
			}
			invalidMsg = null;
			fldValue = Z.getFieldValue(fldName);
			invalidMsg = Z._fieldValidator.checkRequired(fldObj, fldValue);
			if (invalidMsg) {
				Z.setFieldError(fldName, invalidMsg);
			}
		} //end for i
		if(Z._masterDataset &amp;&amp; Z._masterField) {
			var masterDsObj = jslet.data.getDataset(Z._masterDataset),
				masterFldObj = masterDsObj.getField(Z._masterField);
			if(Z.existRecordError()) {
				//'Detail Dataset: {0} has error data!'
				masterDsObj.addFieldError(Z._masterField, jslet.formatMessage(jsletlocale.Dataset.detailDsHasError, [Z.name()]));
			} else {
				masterDsObj.addFieldError(Z._masterField, null);
			}
		}
	},

<span id='jslet-data-Dataset-method-errorMessage'>	/**
</span>	 * @private
	 */
	errorMessage: function(errMessage) {
		var evt = jslet.data.RefreshEvent.errorEvent(errMessage || '');
		this.refreshControl(evt);
	},
	
	addFieldError: function(fldName, errorMsg, valueIndex, inputText) {
		jslet.data.FieldError.put(this.getRecord(), fldName, errorMsg, valueIndex, inputText);
	},
	
<span id='jslet-data-Dataset-method-existRecordError'>	/**
</span>	 * Check whether the specified record exists error.
	 * 
	 * @param {Integer | Object} recnoOrRecord Record number.
	 * @param {String[]} includeFields Checking field names.
	 * @param {String[]} excludeFields Unchecking field names.
	 * 
	 * @return {Boolean} True - exist error, false - otherwise.
	 */
	existRecordError: function(recno, includeFields, excludeFields) {
		return jslet.data.FieldError.existRecordError(this.getRecord(recno), includeFields, excludeFields);
	},
	
	getRecordErrorInfo: function(recno, includeFields, excludeFields) {
		var record = this.getRecord(recno);
		if(!this.existRecordError()) {
			return '';
		}
		var recInfo = jslet.data.getRecInfo(record);
		if(!recInfo) {
			return null;
		}
		var result = '',
			errObj = recInfo.error,
			fldObj;
		if(errObj) {
			for(var fldName in errObj) {
				if(excludeFields &amp;&amp; excludeFields.indexOf(fldName) &gt;= 0) {
					continue;
				}
				if(includeFields &amp;&amp; includeFields.indexOf(fldName) &lt; 0) {
					continue;
				}
				var msg = jslet.data.FieldError.get(record, fldName).message;
				if(msg) {
					fldObj = this.getField(fldName);
					if(result) {
						result += ', ';
					}
					result += msg;
				}
			}
		}
		return result;
	},
	
<span id='jslet-data-Dataset-method-checkAndShowError'>	/**
</span>	 * @private
	 * 
	 * Check show error message if the dataset exists error data.
	 * 
	 * @param {String[]} includeFields Checking field names.
	 * @param {String[]} excludeFields Unchecking field names.
	 * @param {jslet.data.RecordRange} recordRange - checking record range.
	 */
	checkAndShowError: function(includeFields, excludeFields, recordRange) {
		var Z = this;
		if(Z.existDatasetError(includeFields, excludeFields, recordRange)) {
			if (Z._autoShowError) {
				jslet.showError(jsletlocale.Dataset.cannotConfirm, function() {
					Z.focusFirstErrorField();
				}, 2000);
			} else {
				console.warn(jsletlocale.Dataset.cannotConfirm);
				Z.focusFirstErrorField();
			}
			return true;
		}
		return false;
	},
	
<span id='jslet-data-Dataset-method-existDatasetError'>	/**
</span>	 * Check whether the dataset exists error data.
	 * 
	 *     @example
	 *     dsObj.existDatasetError(); //Check all fields
	 *     dsObj.existDatasetError(['fld1', 'fld2']); //Check 'fld1' and 'fld2'
	 * 
	 * @param {String[]} includeFields Checking field names.
	 * @param {String[]} excludeFields Unchecking field names.
	 * @param {jslet.data.RecordRange} recordRange - checking record range.
	 * 
	 * @return {Boolean} True - exist error, false - otherwise.
	 */
	existDatasetError: function(includeFields, excludeFields, recordRange) {
		var Z = this, isError = false,
			records = Z.records();
		if(!records) {
			return false;
		}
		if(recordRange === jslet.data.RecordRange.CURRENT) {
			return jslet.data.FieldError.existRecordError(Z.getRecord(), includeFields, excludeFields);
		}
		if(recordRange === jslet.data.RecordRange.SELECTED) {
			records = Z.selectedRecords() || [];		
		}
		for(var i = 0, len = records.length; i &lt; len; i++) {
			isError = jslet.data.FieldError.existRecordError(records[i], includeFields, excludeFields);
			if(isError) {
				return true;
			}
		}
		return false;
	},
	
<span id='jslet-data-Dataset-method-confirm'>	/**
</span>	 * Confirm the current record which is inserting or updating. This method will validate first, and change the dataset status to 'Browse'.
	 * 
	 * @param {String[]} includeFields Checking field names.
	 * @param {String[]} excludeFields Unchecking field names.
	 * 
	 * @return {Boolean} True - the current record is valid, false - otherwise.
	 */
	confirm: function (includeFields, excludeFields) {
		var Z = this;
		if (Z._status === jslet.data.DataSetStatus.BROWSE) {
			return true;
		}
		var records = Z.records();
		if(!records || records.length ===0) {
			Z._status = jslet.data.DataSetStatus.BROWSE;
			return true;
		}
		Z._fireDatasetEvent(jslet.data.DatasetEvent.BEFORECONFIRM);
		Z._confirmDetailDataset();
		Z._innerValidateData(includeFields, excludeFields);
		if(Z.status() === jslet.data.DataSetStatus.UPDATE) {
			Z.changedStatus(jslet.data.DataSetStatus.UPDATE);
		}
		
		var evt, hasError = Z.existRecordError(Z.recno(), includeFields, excludeFields);
		var rec = Z.getRecord();
		Z._modiObject = null;
		Z.status(jslet.data.DataSetStatus.BROWSE);
		if(!hasError) {
			Z._changeLog.log();
		}
		Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERCONFIRM);
		Z._calcAggregatedValueDebounce.call(Z);
		evt = jslet.data.RefreshEvent.updateRecordEvent();
		Z.refreshControl(evt);
		if(hasError) {
			Z.errorMessage(jsletlocale.Dataset.cannotConfirm);			
		} else {
			jslet.data.FieldError.clearRecordError(Z.getRecord(), includeFields, excludeFields);
			Z.errorMessage();
		}
		var dsMaster = Z.masterDataset();
		if (dsMaster) {
			var masterFldName = Z.masterField();
			if(hasError) {
				//'Detail Dataset: {0} has error data!'
				dsMaster.addFieldError(masterFldName, jslet.formatMessage(jsletlocale.Dataset.detailDsHasError, [Z.name()]));
			} else {
				dsMaster.addFieldError(masterFldName, null);
			}
			dsMaster.refreshControl(evt);
		}
		Z.refreshLookupHostDataset();

		return !hasError;
	},

	/*
	 * @private
	 */
	_confirmDetailDataset: function() {
		var Z = this,
			fldObj, i, len,
			dtlDatasets = [],
			dtlFields = [];
		for (i = 0, len = Z._normalFields.length; i &lt; len; i++) {
			fldObj = Z._normalFields[i];
			if(fldObj.getType() === jslet.data.DataType.DATASET) {
				dtlDatasets.push(fldObj.detailDataset());
				dtlFields.push(fldObj.name());
			}
		}
		var dsDetail, oldShowError;
		for(i = 0, len = dtlDatasets.length; i &lt; len; i++) {
			dsDetail = dtlDatasets[i];
			if(!dsDetail) {
				continue;
			}
			dsDetail.confirm();
			if(dsDetail.existDatasetError()) {
				//'Detail Dataset: {0} has error data!'
				Z.addFieldError(dtlFields[i], jslet.formatMessage(jsletlocale.Dataset.detailDsHasError, [dsDetail.name()]));
			} else {
				Z.addFieldError(dtlFields[i], null);
			}
		}
	},
	
<span id='jslet-data-Dataset-method-cancel'>	/**
</span>	 * Cancel inserting or updating. This method will rollback the current record and change dataset status to 'Browse'.
	 */
	cancel: function () {
		var Z = this;
		if (Z._status == jslet.data.DataSetStatus.BROWSE) {
			return this;
		}
		if (Z.recordCount() === 0) {
			return this;
		}
		Z._aborted = false;
		try {
			Z._fireDatasetEvent(jslet.data.DatasetEvent.BEFORECANCEL);
			if (Z._aborted) {
				return this;
			}
		} finally {
			Z._aborted = false;
		}
		 Z._cancelDetailDataset();
		 var evt, 
			k = Z._recno,
			records = Z.records();
		if (Z._status == jslet.data.DataSetStatus.INSERT) {
			Z.selection.removeAll();
			var no = Z.recno();
			records.splice(k, 1);
			Z.status(jslet.data.DataSetStatus.BROWSE);
			Z._refreshInnerRecno();
			if(no &gt;= Z.recordCount()) {
				Z._recno = Z.recordCount() - 1;
			}
			Z._refreshProxyField();
			if (Z._contextRuleEnabled) {
				this.calcContextRule();
			}

			Z._calcAggregatedValueDebounce.call(Z);
			evt = jslet.data.RefreshEvent.deleteEvent(no);
			Z.refreshControl(evt);
			Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERSCROLL);
			evt = jslet.data.RefreshEvent.scrollEvent(Z._recno); 
			Z.refreshControl(evt); 
			return this;
		} else {
			if (Z._filteredRecnoArray) {
				k = Z._filteredRecnoArray[Z._recno];
			}
			var currRec = records[k];
			var modiObj = Z._modiObject;
			jQuery.extend(currRec, modiObj);
			for(var propName in currRec) {
				if(modiObj[propName] === undefined) {
					delete currRec[propName];
				}
			}
			Z._innerValidateData();

			jslet.data.FieldValueCache.removeCache(currRec);
			Z._modiObject = null;
		}

		Z._refreshProxyField();
		Z._calcAggregatedValueDebounce.call(Z);
		Z.status(jslet.data.DataSetStatus.BROWSE);
		Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERCANCEL);

		evt = jslet.data.RefreshEvent.updateRecordEvent();
		Z.refreshControl(evt);
		return this;
	},

    /*
     * @private
     */
    _cancelDetailDataset: function() {
        var Z = this,
            fldObj, i, len,
            detailDatasets = [];
        for (i = 0, len = Z._normalFields.length; i &lt; len; i++) {
            fldObj = Z._normalFields[i];
            if(fldObj.getType() === jslet.data.DataType.DATASET) {
                detailDatasets.push(fldObj.detailDataset());
            }
        }
        var dsDetail;
        for(i = 0, len = detailDatasets.length; i &lt; len; i++) {
            dsDetail = detailDatasets[i];
            dsDetail.cancel();
        }
    },
     
<span id='jslet-data-Dataset-property-logChanges'>	/**
</span>	 * @property
	 * 
	 * If logChanges is false, the changes made by user will not be send to server. &lt;br /&gt;
	 * If you don't need submit data to server, you can set this property value to false.
	 * &lt;br /&gt;Default value: true. Example:
	 * 
	 *     @example
	 *     dsObj.logChanges(true); //Set property, return this.
	 *     var propValue = dsObj.logChanges(); //Get property value.
	 * 
	 * @param {Boolean | undefined} logChanges - True: log user changes, false - otherwise.
	 * 
	 * @return {this | Boolean}
	 */
	logChanges: function (logChanges) {
		if (logChanges === undefined) {
			return this._logChanges;
		}

		this._logChanges = logChanges;
		return this;
	},

<span id='jslet-data-Dataset-method-auditLogEnabled'>	/**
</span>	 * Edit log means the log when user modify records. For some sensitive data, user need audit who &amp; when modify data. Example: 
	 * 
	 *     @example
	 *     dsObj.auditLogEnabled(true); //Set property, return this.
	 *     var propValue = dsObj.auditLogEnabled(); //Get property value.
	 * 
	 * @param {Boolean | undefined} auditLogEnabled - True: enable audit log, false - otherwise.
	 * 
	 * @return {this | Boolean}
	 */
	auditLogEnabled: function(auditLogEnabled) {
		if(auditLogEnabled === undefined) {
			return this._auditLogEnabled;
		}
		this._auditLogEnabled = auditLogEnabled? true: false;
		return this;
	},
	
<span id='jslet-data-Dataset-method-validationEnabled'>	/**
</span>	 * Identify whether enable field value validating or not. Example: 
	 * 
	 *     @example
	 *     dsObj.validationEnabled(true); //Set property, return this.
	 *     var propValue = dsObj.validationEnabled(); //Get property value.
	 * 
	 * @param {Boolean | undefined} validationEnabled - True: enable field value validating, false - otherwise.
	 * 
	 * @return {this | Boolean}
	 */
	validationEnabled: function(validationEnabled) {
		if(validationEnabled === undefined) {
			return this._validationEnabled;
		}
		this._validationEnabled = validationEnabled? true: false;
		return this;
	},
	
<span id='jslet-data-Dataset-method-disableControls'>	/**
</span>	 * Disable refreshing controls, it's always used in a batch operation;
	 * After batch operating, use {@link jslet.data.Dataset#enableControls}(). Example:
	 * 
	 *     @example
	 *     dsObj.disableControls();
	 *     try {
	 *       dsObj.setFieldValue('fld1', 123); //It won't refresh UI.
	 *       ...
	 *     } finally {
	 *       dsObj.enableControls();
	 *     }
	 * 
	 * @return {this}
	 */
	disableControls: function () {
		this._lockCount++;
		var fldObj, dsDetail;
		for (var i = 0, cnt = this._normalFields.length; i &lt; cnt; i++) {
			fldObj = this._normalFields[i];
			dsDetail = fldObj.detailDataset();
			if (dsDetail !== null) {				
				dsDetail.disableControls();
			}
		}
		return this;
	},

<span id='jslet-data-Dataset-method-enableControls'>	/**
</span>	 * Enable refreshing controls.. Example:
	 * 
	 *     @example
	 *     dsObj.disableControls();
	 *     try {
	 *       dsObj.setFieldValue('fld1', 123); //It won't refresh UI.
	 *       ...
	 *     } finally {
	 *       dsObj.enableControls();
	 *     }
	 * 
	 * @param {Boolean} refreshCtrl true - Refresh control immediately, false - Otherwise.
	 * 
	 * @return {this}
	 */
	enableControls: function (needRefreshCtrl) {
		if (this._lockCount &gt; 0) {
			this._lockCount--;
		}
		if (!needRefreshCtrl) {
			this.refreshControl();
		}

		var fldObj, dsDetail;
		for (var i = 0, cnt = this._normalFields.length; i &lt; cnt; i++) {
			fldObj = this._normalFields[i];
			dsDetail = fldObj.detailDataset();
			if (dsDetail !== null) {				
				dsDetail.enableControls();
			}
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-existFieldError'>	/**
</span>	 * Check whether the specified field of current record is valid or not.
	 * 
	 * @param {String} fldName Field name;
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * 
	 * @return {Boolean} True - exists invalid data, false -otherwise.
	 */
	existFieldError: function(fldName, valueIndex) {
		if (this.recordCount() === 0) {
			return false;
		}

		var currRec = this.getRecord();
		if (!currRec) {
			return false;
		}
		return jslet.data.FieldError.existFieldError(currRec, fldName, valueIndex);
	},
	
<span id='jslet-data-Dataset-method-getFieldError'>	/**
</span>	 * Get the specified field error message of current record. Example:
	 * 
	 *     @example
	 *     var errorObj = dataset.getFieldError('field1'); //return: {message: 'Not Exists!', inputText: 'Foo'}
	 * 
	 * @param {String} fldName Field name.
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * 
	 * @return {Object} Error Object, like {message: 'Not Exists!', inputText: 'Foo'}
	 */
	getFieldError: function(fldName, valueIndex) {
		return this.getFieldErrorByRecno(null, fldName, valueIndex);
	},
	
<span id='jslet-data-Dataset-method-getFieldErrorByRecno'>	/**
</span>	 * Get the specified field error message of specified record. Example:
	 * 
	 *     @example
	 *     var errorObj = getFieldErrorByRecno(19, 'field1'); //return: {message: 'Not Exists!', inputText: 'Foo'}
	 * 
	 * @param {Integer} recno Record Number.
	 * @param {String} fldName Field name.
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * 
	 * @return {Object} Error Object, like {message: 'Not Exists!', inputText: 'Foo'}
	 */
	getFieldErrorByRecno: function(recno, fldName, valueIndex) {
		if (this.recordCount() === 0) {
			return null;
		}

		var currRec = this.getRecord(recno);
		if (!currRec) {
			return null;
		}
		return jslet.data.FieldError.get(currRec, fldName, valueIndex);
	},
	
<span id='jslet-data-Dataset-method-setFieldError'>	/**
</span>	 * Set the specified field error message of current record. Example:
	 * 
	 *     @example
	 * 	   var errorObj = dataset.setFieldError('field1', 'Not Exists!', null, 'Foo');
	 * 
	 * @param {String} fldName Field name.
	 * @param {String} errorMsg Field error message.
	 * @param {Integer} valueIndex (Optional)Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * @param {String} inputText (Optional)User input text.
	 * 
	 * @return {this}
	 */
	setFieldError: function(fldName, errorMsg, valueIndex, inputText) {
		var Z = this;
		if (Z.recordCount() === 0) {
			return Z;
		}

		var currRec = Z.getRecord();
		if (!currRec) {
			return Z;
		}
		jslet.data.FieldError.put(currRec, fldName, errorMsg, valueIndex, inputText);
		return this;
	},
		
<span id='jslet-data-Dataset-method-getFieldValueByRecno'>	/**
</span>	 * Get field value with specified record number and field name.
	 * 
	 *     @example
	 *     dsObj.getFieldValueByRecno(2, 'fld1');
	 *     dsObj.getFieldValueByRecno(2, 'fld2', 0); //fld2 value is an array.
	 * 
	 * @param {Integer} recno Specified record number.
	 * @param {String} fldName Field name.
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * 
	 * @return {Object} field value.
	 */
	getFieldValueByRecno: function(recno, fldName, valueIndex) {
		var dataRec = this.getRecord(recno);
		if(!dataRec) {
			return null;
		}
		return this.getFieldValueByRecord(dataRec, fldName, valueIndex);
	},
	
<span id='jslet-data-Dataset-method-getFieldValueByRecord'>	/**
</span>	 * Get field value of specified record.
	 * 
	 *     @example
	 *     var recObj = dsObj.getRecord(2);
	 *     dsObj.getFieldValueByRecno(recObj, 'fld1');
	 *     dsObj.getFieldValueByRecno(recObj, 'fld2', 0); //fld2 value is an array.
	 * 
	 * @param {Object} dataRec Specified record.
	 * @param {String} fldName Field name.
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * 
	 * @return {Object} field value.
	 */
	getFieldValueByRecord: function (dataRec, fldName, valueIndex) {
		var Z = this;

		if (!dataRec) {
			dataRec = Z.getRecord();
		}
		Z._refreshProxyField(dataRec, true);

		var k = fldName.indexOf('.'), 
			dtlFldName, fldValue = null,
			fldObj = Z.getField(fldName),
			value, lkds;
		if (k &gt; 0) { //field chain
			dtlFldName = fldName.substr(0, k);
			fldObj = Z.getField(dtlFldName);
			var lkf = fldObj.lookup(),
				dsDetail = fldObj.detailDataset();
			
			if (!lkf &amp;&amp; !dsDetail) {
				throw new Error(jslet.formatMessage(jsletlocale.Dataset.lookupNotFound, [dtlFldName]));
			}
			if(lkf) {
				value = jslet.data.FieldRawValueAccessor.getRawValue(dataRec, fldObj);
				lkds = lkf.dataset();
				fldValue = null;
				if(value || value === 0) {
					if (lkds.findByField(lkds.keyField(), value)) {
						fldValue = lkds.getFieldValue(fldName.substr(k + 1));
					} else {
						console.warn(jslet.formatMessage(jsletlocale.Dataset.valueNotFound,
								[lkds.description(), lkds.keyField(), value]));
					}
				}
			} else {
				fldValue = dsDetail.getFieldValue(fldName.substr(k + 1));
			}
			
		} else { //single field
			if (!fldObj) {
				throw new Error(jslet.formatMessage(jsletlocale.Dataset.fieldNotFound, [fldName]));
			}
			var formula = fldObj.formula();
			if (!formula) {
				fldValue = jslet.data.FieldRawValueAccessor.getRawValue(dataRec, fldObj);
			} else {
				if(dataRec[fldName] === undefined) {
					fldValue = Z._calcFormula(dataRec, fldName);
					jslet.data.FieldRawValueAccessor.setRawValue(dataRec, fldObj, fldValue);
				} else {
					fldValue = jslet.data.FieldRawValueAccessor.getRawValue(dataRec, fldObj);
				}
			}
		}

		if(!fldObj.valueStyle() || valueIndex === undefined) { //jslet.data.FieldValueStyle.NORMAL
			return fldValue;
		}
		return jslet.getArrayValue(fldValue, valueIndex);
	},

<span id='jslet-data-Dataset-method-getFieldValue'>	/**
</span>	 * Get field value of current record.
	 * 
	 *     @example
	 *     dsObj.getFieldValue('fld1');
	 *     dsObj.getFieldValue('fld2', 0); //fld2 value is an array.
	 * 
	 * @param {String} fldName Field name.
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * 
	 * @return {Object}
	 */
	getFieldValue: function (fldName, valueIndex) {
		var currRec = this.getRecord();
		if (!currRec) {
			return null;
		}
		return this.getFieldValueByRecord(currRec, fldName, valueIndex);
	},

	_convertValueByType: function(fldName, value, dataType, scale, trimBlank) {
		if(!value || dataType === jslet.data.DataType.DATASET) {
			return value;
		}
		if(jslet.isArray(value)) {
			for(var i = 0, len = value.length; i &lt; len; i++) {
				value[i] = this._convertValueByType(fldName, value[i], dataType, scale, trimBlank);
			}
			return value;
		}
		if(dataType === jslet.data.DataType.NUMBER) {
			var oldValue = value;
			value = scale &gt; 0 ? parseFloat(value): parseInt(value);
			if(window.isNaN(value)) {
				//Invalid value: [{1}] for NUMBER field: [{0}]!
				throw new Error(jslet.formatMessage(jsletlocale.Dataset.invalidNumberFieldValue, [fldName, oldValue]));
			}
			return value;
		}
		if(trimBlank &amp;&amp; dataType === jslet.data.DataType.STRING &amp;&amp; jslet.isString(value)) {
			return value.trim();
		}
		return value;
	},
	
<span id='jslet-data-Dataset-method-setFieldValue'>	/**
</span>	 * Set field value of current record.
	 * 
	 *     @example
	 *     dsObj.setFieldValue('fld1', 123);
	 *     dsObj.getFieldValue('fld2', ['one', 'two']); //fld2 value is an array.
	 *     dsObj.getFieldValue('fld2', 'one1', 0); //fld2 value is an array.
	 * 
	 * @param {String} fldName Field name.
	 * @param {Object} value Field value.
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * 
	 * @return {this}
	 */
	setFieldValue: function (fldName, value, valueIndex) {
		var Z = this,
			fldObj = Z.getField(fldName);
		if (fldObj === null) {
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.fieldNotFound, [fldName]));
		}
		if(Z._status == jslet.data.DataSetStatus.BROWSE) {
			Z.editRecord();
		}
		var auditLogRec = Z._logOldEditValue(fldName, fldObj.label());
		var currRec = Z.getRecord(),
			dataType = fldObj.getType();
		value = Z._convertValueByType(fldName, value, dataType, fldObj.scale(), fldObj.trimBlank());
		
		if(Z._validationEnabled) {
			var invalidMsg = Z._fieldValidator.checkValue(fldObj, value);
			if(invalidMsg) {
				Z.setFieldError(fldName, invalidMsg);
			} else {
				Z.setFieldError(fldName, null, valueIndex);
			}
		}
		if(!fldObj.valueStyle() || valueIndex === undefined) { //jslet.data.FieldValueStyle.NORMAL
			jslet.data.FieldRawValueAccessor.setRawValue(currRec, fldObj, value);
			if (dataType == jslet.data.DataType.DATASET) {//dataset field
				return this;
			}
		} else {
			var arrValue = jslet.data.FieldRawValueAccessor.getRawValue(currRec, fldObj);

			if(!arrValue || !jslet.isArray(arrValue)) {
				arrValue = [];
			}
			var len = arrValue.length;
			if(valueIndex &lt; len) {
				arrValue[valueIndex] = value;
			} else {
				for(var i = len; i &lt; valueIndex; i++) {
					arrValue.push(null);
				}
				arrValue.push(value);
			}
			
			jslet.data.FieldRawValueAccessor.setRawValue(currRec, fldObj, arrValue);
		}
		if (Z._onFieldChanged) {
			var eventFunc = jslet.getFunction(Z._onFieldChanged);
			if(eventFunc) {
				eventFunc.call(Z, fldName, value, valueIndex);
				value = Z.getFieldValue(fldName, valueIndex);
			}
		}
		if(Z.isFireGlobalEvent()) {
			var globalHandler = jslet.data.globalDataHandler.fieldValueChanged();
			if(globalHandler) {
				globalHandler.call(Z, Z, fldName, value, valueIndex);
			}
		}
		if(fldObj.valueFollow()) {
			if(!Z._followedValues) {
				Z._followedValues = {};
			}
			Z._followedValues[fldName] = value;
		}
		Z._refreshProxyField(currRec, true);
		//calc other fields' range to use context rule
		if (Z._contextRuleEnabled) {
			Z.calcContextRule(fldName);
		}
		jslet.data.FieldValueCache.clear(currRec, fldName);
		Z._logNewEditValue(fldName, auditLogRec);
		Z._updateLookupRelativeFields(fldObj, value);
		var evt = jslet.data.RefreshEvent.updateRecordEvent(fldName);
		Z.refreshControl(evt);
		Z.updateFormula(fldName);
		Z._calcAggregatedValueDebounce.call(Z);
		return this;
	},

	_logOldEditValue: function(fldName, fldLabel) {
		var Z = this;
		if(!Z._auditLogEnabled || !Z._logChanges) {
			return null;
		}
		var status = Z.changedStatus() || Z._status;
		if(status !== jslet.data.DataSetStatus.UPDATE) {
			return null;
		}
		var currRec = Z.getRecord(); 
		var auditLog = currRec[jslet.global.auditLogField];
		if(!auditLog) {
			auditLog = {};
			currRec[jslet.global.auditLogField] = auditLog;
		}
		var logRec = auditLog[fldName];
		if(!logRec) {
			logRec = {};
			auditLog[fldName] = logRec;
			logRec.l = fldLabel;
		}
		var oldValue = logRec.o;
		if(!oldValue) {
			logRec.o = Z.getFieldText(fldName);
		}
		return logRec;
	},
	
	_logNewEditValue: function(fldName, auditLogRec) {
		if(auditLogRec) {
			var newValue = this.getFieldText(fldName);
			if(newValue != auditLogRec.o) {
				auditLogRec.n = newValue;
			} else {
				var currRec = this.getRecord(); 
				var auditLog = currRec[jslet.global.auditLogField];
				delete auditLog[fldName];
			}
		}
	},
	
	clearFollowedValues: function() {
		this._followedValues = null;
		return this;
	},
	
	calcFocusedFields: function() {
		var Z = this, fldObj;
		Z._focusedFields = null;
		for(var i = 0, len = Z._normalFields.length; i &lt; len; i++) {
			fldObj = Z._normalFields[i];
			if(fldObj.focused()) {
				if(!Z._focusedFields) {
					Z._focusedFields = [];
				}
				Z._focusedFields.push(fldObj.name());
			}
		}
		if(Z.masterField()) {
			var masterDsObj = jslet.data.getDataset(Z._masterDataset),
				masterFldObj = masterDsObj.getField(Z._masterField);
			masterFldObj.focused(Z._focusedFields &amp;&amp; Z._focusedFields.length &gt; 0);
		}
	},
	
	focusedFields: function() {
		return this._focusedFields;
	},
	
	mergedFocusedFields: function() {
		var fields = this._focusedFields,
			result = fields,
			canFields = this._canFocusFields,
			fldName, fldObj;
		if(fields &amp;&amp; canFields) {
			for(var i = fields.length - 1; i &gt;= 0; i--) {
				fldName = fields[i];
				fldObj = this.getField(fldName);
				if(fldObj.detailDataset()) {
					continue;
				}
				if(canFields.indexOf(fldName) &lt; 0) {
					result = fields.slice(0);
					result.splice(i, 1);
				}
			}
		}
		return result;
	},
	
	_updateLookupRelativeFields: function(fldObj, fldValue) {
		//Only single value can update relative fields.
		if(!fldValue || fldObj.valueStyle() !== jslet.data.FieldValueStyle.NORMAL) {
			return;
		}
		var lkObj = fldObj.lookup();
		if(!lkObj) {
			return;
		}
		var lkRtnFldMap = lkObj.returnFieldMap();
		if(!lkRtnFldMap) {
			return;
		}
		var lkFldName, lkDs = lkObj.dataset();
		if(jslet.compareValue(lkDs.keyValue(), fldValue) !== 0) {
			if(!lkDs.findByKey(fldValue)) {
				return;
			}
		}
		var keyFldName = fldObj.name();
		for(var fldName in lkRtnFldMap) {
			//Avoid setting value to key field.
			if(keyFldName == fldName) {
				continue;
			}
			lkFldName = lkRtnFldMap[fldName];
			this.setFieldValue(fldName, lkDs.getFieldValue(lkFldName));
		}
		
	},
	
	_calcFormulaRelation: function() {
		var Z = this;
		if(!Z._innerFormularFields) {
			return;
		}
		var fldName, formulaFields, formulaFldName, fldObj,
			relation = {}, 
			count = 0;
		for(var fldName in Z._innerFormularFields) {
			var evaluator = Z._innerFormularFields[fldName];
			formulaFields = evaluator.mainFields();
			relation[fldName] = formulaFields;
			count++;
		}
		Z._innerFormulaRelation = count &gt; 0? relation: null;
	},
	
<span id='jslet-data-Dataset-method-addInnerFormulaField'>	/**
</span>	 * @private
	 */
	addInnerFormulaField: function(fldName, formula) {
		var Z = this;
		if(!formula) {
			return;
		}
		if (!Z._innerFormularFields) {
			Z._innerFormularFields = {};
		}
		var evaluator = new jslet.data.Expression(Z, formula);
		Z._innerFormularFields[fldName] = evaluator;
		Z._calcFormulaRelation();
	},
	
<span id='jslet-data-Dataset-method-removeInnerFormulaField'>	/**
</span>	 * @private
	 */
	removeInnerFormulaField: function (fldName) {
		if (this._innerFormularFields) {
			delete this._innerFormularFields[fldName];
			this._calcFormulaRelation();
		}
	},

	_calcFormula: function(currRec, fldName) {
		var Z = this,
			evaluator = Z._innerFormularFields[fldName],
			result = null;
		if(evaluator) {
			evaluator.context.dataRec = currRec;
			result = evaluator.eval();
		}
		return result;
	},
	
<span id='jslet-data-Dataset-method-updateFormula'>	/**
</span>	 * @private
	 */
	updateFormula: function (changedFldName) {
		var Z = this;
		if(!Z._innerFormulaRelation) {
			return;
		}
		var fields, fldObj,
			currRec = this.getRecord();
		for(var fmlFldName in Z._innerFormulaRelation) {
			fields = Z._innerFormulaRelation[fmlFldName];
			fldObj = Z.getField(fmlFldName);
			if(!fields || fields.length === 0) {
				fldObj.setValue(Z._calcFormula(currRec, fmlFldName));
				continue;
			}
			var found = false, fldName;
			for(var j = 0, cnt = fields.length; j &lt; cnt; j++) {
				fldName = fields[j];
				if(fldName == changedFldName || fldName.startsWith(changedFldName + '.')) {
					found = true;
					break;
				}
			}
			if(found) {
				fldObj.setValue(Z._calcFormula(currRec, fmlFldName));
			}
		}
	},
	
<span id='jslet-data-Dataset-method-getFieldText'>	/**
</span>	 * Get field text. Difference of field text and field value: &lt;br /&gt;
	 * Field value: the original value which request from server or send to server. &lt;br /&gt;
	 * Field text: the formatting text from field value, it includes two types: 'Input Text' and 'Display Text', an example for them:&lt;br /&gt;
	 * Suppose one field value is currency, 'Input Text' is '90123.56', and 'Display Text' is '$90,123.56'. &lt;br /&gt;
	 * Example:
	 * 
	 *     @example
	 *     dsObj.setFieldValue('fld1', 90123.56);
	 *     dsObj.getFieldText('fld1', true); //return '90123.56'
	 *     dsObj.getFieldText('fld1'); //return '$90,123.56'(DisplayFormat is: '$#,##0.00)
	 * 
	 * @param {String} fldName Field name.
	 * @param {Boolean} isEditing (optional) In edit mode or not, if in edit mode, return 'Input Text'(user inputting text), else return 'Display Text'(Display text is almost formatted). 
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, starts with 0.
	 * 
	 * @return {String} Field text.
	 */
	getFieldText: function (fldName, isEditing, valueIndex) {
		if (this.recordCount() === 0) {
			return null;
		}

		var currRec = this.getRecord();
		if (!currRec) {
			return null;
		}
		return this.getFieldTextByRecord(currRec, fldName, isEditing, valueIndex);
	},
	
<span id='jslet-data-Dataset-method-getFieldTextByRecno'>	/**
</span>	 * Get field display text by record number.
	 * 
	 * @param {Object} recno Record number.
	 * @param {String} fldName Field name
	 * @param {Boolean} isEditing (optional) In edit mode or not, if in edit mode, return 'Input Text'(user inputting text), else return 'Display Text'(Display text is almost formatted). 
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, start with 0.
	 * 
	 * @return {String} Field text.
	 */
	getFieldTextByRecno: function (recno, fldName, isEditing, valueIndex) {
		var dataRec = this.getRecord(recno);
		if(!dataRec) {
			return null;
		}
		return this.getFieldTextByRecord(dataRec, fldName, isEditing, valueIndex);
	},
	
<span id='jslet-data-Dataset-method-getFieldTextByRecord'>	/**
</span>	 * Get field display text with data record.
	 * 
	 * @param {Object} dataRec Data record.
	 * @param {String} fldName Field name.
	 * @param {Boolean} isEditing (optional) In edit mode or not, if in edit mode, return 'Input Text'(user inputting text), else return 'Display Text'(Display text is almost formatted). 
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, starts with 0.
	 * 
	 * @return {String} Field text.
	 */
	getFieldTextByRecord: function (dataRec, fldName, isEditing, valueIndex) {
		var Z = this;
		if (Z.recordCount() === 0) {
			return '';
		}
		var currRec = dataRec, fldObj;
		
		Z._refreshProxyField(currRec, true);
		
		var k = fldName.indexOf('.'), value;
		if (k &gt; 0) { //Field chain
			var dtlFldName = fldName.substr(0, k);
			fldName = fldName.substr(k + 1);
			fldObj = Z.getField(dtlFldName);
			if (!fldObj) {
				throw new Error(jslet.formatMessage(jsletlocale.Dataset.fieldNotFound, [fldName]));
			}
			var lkf = fldObj.lookup(),
				dsDetail = fldObj.detailDataset();
			if (!lkf &amp;&amp; !dsDetail) {
				throw new Error(jslet.formatMessage(jsletlocale.Dataset.lookupNotFound, [fldName]));
			}
			if(lkf) {
				value = currRec[dtlFldName];
				if (value === null || value === undefined) {
					return '';
				}
				var lkds = lkf.dataset();
				if (lkds.findByField(lkds.keyField(), value)) {
					if (fldName.indexOf('.') &gt; 0) {
						return lkds.getFieldValue(fldName);
					} else {
						return lkds.getFieldText(fldName, isEditing, valueIndex);
					}
				} else {
					throw new Error(jslet.formatMessage(jsletlocale.Dataset.valueNotFound,
							[lkds.description(), lkds.keyField(), value]));
				}
			} else {
				//Can't use it in sort function.
				return dsDetail.getFieldText(fldName, isEditing, valueIndex);
			}
		}
		//Not field chain
		fldObj = Z.getField(fldName);
		if (!fldObj) {
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.lookupNotFound, [fldName]));
		}
		if (fldObj.getType() == jslet.data.DataType.DATASET) {
			return '';
		}
		var valueStyle = fldObj.valueStyle();
		
		if(valueStyle === jslet.data.FieldValueStyle.NORMAL || valueIndex !== undefined) {
			var errObj = jslet.data.FieldError.get(currRec, fldName, valueIndex);
			if(errObj &amp;&amp; errObj.message) {
				var inputText = errObj.inputText;
				if(inputText !== undefined &amp;&amp; inputText !== null) {
					return inputText;
				}
			}
		}
		var result = [];
		if(valueStyle == jslet.data.FieldValueStyle.BETWEEN &amp;&amp; valueIndex === undefined)
		{
			var minVal = Z.getFieldTextByRecord(currRec, fldName, isEditing, 0),
				maxVal = Z.getFieldTextByRecord(currRec, fldName, isEditing, 1);
			if(!isEditing &amp;&amp; !minVal &amp;&amp; !maxVal){
				return '';
			}
			result.push(minVal);
			if(isEditing) {
				result.push(jslet.global.valueSeparator);
			} else {
				result.push(jsletlocale.Dataset.betweenLabel);
			}
			result.push(maxVal);
			return result.join('');
		}
		
		if(valueStyle == jslet.data.FieldValueStyle.MULTIPLE &amp;&amp; valueIndex === undefined)
		{
			var arrValues = Z.getFieldValue(fldName), 
				len = 0;
			if(arrValues &amp;&amp; jslet.isArray(arrValues)) {
				len = arrValues.length - 1;
			}
			
			for(var i = 0; i &lt;= len; i++) {
				result.push(Z.getFieldTextByRecord(currRec, fldName, isEditing, i));
				if(i &lt; len) {
					result.push(jslet.global.valueSeparator);
				}
			}
			return result.join('');
		}
		//Get cached display value if exists.
		if(!isEditing) {
			var cacheValue = jslet.data.FieldValueCache.get(currRec, fldName, valueIndex);
			if(cacheValue !== undefined) {
				return cacheValue;
			}
		}
		value = Z.getFieldValueByRecord(currRec, fldName, valueIndex);
		if (value === null || value === undefined) {
			var fixedValue = fldObj.fixedValue();
			if(fixedValue) {
				return fixedValue;
			}
			return '';
		}

		var convert = fldObj.customValueConverter() || jslet.data.getValueConverter(fldObj);
		if(!convert) {
			throw new Error('Can\'t find any field value converter!');
		}
		var text = convert.valueToText(fldObj, value, isEditing);
		var encrypted = fldObj.encrypted(); 
		if(!isEditing &amp;&amp; encrypted &amp;&amp; text) {
			var start = encrypted.start || 0,
				end = encrypted.end;
			if(end === undefined || end === null || end &lt; start) {
				end = 10000;
			}
			var txtLen = text.length;
			end = txtLen &lt; end? txtLen: end;
			var oldText = text;
			text = oldText.substring(0, start); 
			for(var k = start; k &lt; end; k++) {
				text += '*';
			}
			if(txtLen &gt; end) {
				text += oldText.substring(end); 
			}
		}
		//Put display value into cache
		if(!isEditing) {
			jslet.data.FieldValueCache.put(currRec, fldName, text, valueIndex);
		}
		return text;
	},
	
<span id='jslet-data-Dataset-method-setFieldValueLength'>	/**
</span>	 * @private
	 */
	setFieldValueLength: function(fldObj, valueLength) {
		if(!fldObj.valueStyle()) { //jslet.data.FieldValueStyle.NORMAL
			return;
		}
		var value = this.getFieldValue(fldObj.name());
		if(value &amp;&amp; jslet.isArray(value)) {
			value.length = valueLength;
		}
	},
	
<span id='jslet-data-Dataset-method-setFieldText'>	/**
</span>	 * Set field value by input value. Example:
	 * 
	 *     @example
	 *     //Field 'department' is a lookup field.
	 *     dsObj.setFieldText('department', '0112'); //input department code
	 *     dsObj.getFieldValue('department'); //return department id: 33
	 *     dsObj.getFieldText('department'); //return department name: 'Sales Dept.'
	 *      
	 * @param {String} fldName Field name.
	 * @param {String} inputText String value inputed by user.
	 * @param {Integer} valueIndex (optional) Field value index, only used for field.valueStyle is BETWEEN or MULTIPLE, starts with 0.
	 */
	setFieldText: function (fldName, inputText, valueIndex) {
		var Z = this,
		fldObj = Z.getField(fldName);
		if (fldObj === null) {
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.fieldNotFound, [fldName]));
		}
		var fType = fldObj.getType();
		if (fType == jslet.data.DataType.DATASET) {
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.datasetFieldNotBeSetValue, [fldName]));
		}
		
		var value = Z._textToValue(fldObj, inputText, valueIndex);
		if(value !== undefined) {
			Z.setFieldValue(fldName, value, valueIndex);
		}
		return this;
	},

	_textToValue: function(fldObj, inputText, valueIndex) {
		var Z = this, value;
		
		if((fldObj.valueStyle() === jslet.data.FieldValueStyle.BETWEEN ||
			fldObj.valueStyle() === jslet.data.FieldValueStyle.MULTIPLE) &amp;&amp; 				
			valueIndex === undefined) {
			//Set an array value
			if(!jslet.isArray(inputText)) {
				inputText = inputText.split(jslet.global.valueSeparator);
			}
			var len = inputText.length, 
				values = [],
				invalid = false;
			for(var k = 0; k &lt; len; k++ ) {
				value = Z._textToValue(fldObj, inputText[k], k);
				if(value === undefined) {
					invalid = true;
				} else {
					if(!invalid) {
						values.push(value);
					}
				}
			}
			if(!invalid) {
				return values;
			}
			return undefined;
		}
		
		var convert = fldObj.customValueConverter() || jslet.data.getValueConverter(fldObj);
		if(!convert) {
			throw new Error('Can\'t find any field value converter!');
		}
		value = convert.textToValue(fldObj, inputText, valueIndex);
		var fldName = fldObj.name();
		if(Z.getFieldError(fldName, valueIndex)) {
			var evt = jslet.data.RefreshEvent.updateRecordEvent(fldName);
			Z.refreshControl(evt);
		} else {
			Z.setFieldError(fldName, null, valueIndex);
		}
		return value;
	},
	
<span id='jslet-data-Dataset-method-keyValue'>	/**
</span>	 * Get key value of current record. 
	 * &lt;br /&gt;Key value is field value of key field, and key field is defined by property {@link jslet.data.Dataset#keyField}.
	 * 
	 * @param {Integer} recno (optional) If not specified, it will get key value of current record.
	 * @return {Object} Key value.
	 */
	keyValue: function (recno) {
		if (!this._keyField || this.recordCount() === 0) {
			return null;
		}
		return this.getFieldValueByRecno(recno, this._keyField);
	},

<span id='jslet-data-Dataset-method-parentValue'>	/**
</span>	 * Get parent record key value of current record.
	 * &lt;br /&gt;Key value is field value of parent field, and parent field is defined by property {@link jslet.data.Dataset#parentField}.
	 * 
	 * @param {Integer} recno recno optional, if not specified, it will get parent key value of current record.
	 * 
	 * @return {Object} Parent record key value.
	 */
	parentValue: function (recno) {
		if (!this._parentField || this.recordCount() === 0) {
			return null;
		}
		return this.getFieldValueByRecno(recno, this._parentField);
	},

<span id='jslet-data-Dataset-method-find'>	/**
</span>	 * Find record with specified condition
	 * if found, then move cursor to that record. Example:
	 * 
	 *     @example
	 *     dsObj.find('like([name],&quot;Bob%&quot;)'); //Finding the one whose name starts with 'Bob'.
	 *     dsObj.find(&quot;'[age] &gt; 20' &amp;&amp; [gender] == 'F'&quot;); //Finding girls whose age is great than 20. 
	 *     dsObj.find('[age] &gt; 20', true); //Find next
	 *     
	 * @param {String} condition Condition expression.
	 * @param {Boolean} fromCurrentPosition Identify whether finding data from current position or not.
	 * 
	 * @return {Boolean} True - found record, false - otherwise.
	 */
	find: function (condition, fromCurrentPosition) {
		var Z = this;
		if (Z.recordCount() === 0) {
			return false;
		}
		Z.confirm();
		if (condition === null || condition === undefined) {
			Z._findCondition = null;
			Z._innerFindCondition = null;
			Z._findPrevRecno = null;
			return false;
		}
		jslet.Checker.test('find#condition', condition).isString();
		
		if (condition !== Z._findCondition) {
			Z._innerFindCondition = new jslet.data.Expression(this, condition);
			Z._findCondition = condition;
			Z._findPrevRecno = null;
		}
		Z._silence++;
		var foundRecno = -1, 
			oldRecno = Z._recno;
		try {
			if(!fromCurrentPosition) {
				Z.first();
				Z._findPrevRecno = null;
			} else {
				if(Z._findPrevRecno === oldRecno) {
					Z.next();
				}
			}
			while (!Z.isEof()) {
				if (Z._innerFindCondition.eval()) {
					foundRecno = Z._recno;
					break;
				}
				Z.next();
			}
		} finally {
			Z._silence--;
			Z._recno = oldRecno;
		}
		if (foundRecno &gt;= 0) {// can fire scroll event
			Z._gotoRecno(foundRecno);
			if(fromCurrentPosition) {
				Z._findPrevRecno = foundRecno;
			}
			return true;
		}
		return false;
	},

<span id='jslet-data-Dataset-method-findByField'>	/**
</span>	 * Find record with specified field name and value. If found, move cursor the found record.
	 * 
	 *     @example
	 *     dsObj.findByField('name', 'Tom'); // return true
	 *     dsObj.findByField('id,name', '5');
	 *     dsObj.findByField('id,name', 'Jack');
	 *     dsObj.findByField(['id', 'name'], '7');
	 *     dsObj.findByField('name', 'Tom', {matchType: 'first'}); // return true
	 *   
	 * @param {String | String[]} fieldNameOrFieldArray Field name, field name array or fields separated with ','.
	 * @param {Object} findingValue Finding value.
	 * @param {Object} options Finding options.
	 * @param {Integer} options.startRecno (optional) Start position to find value, default is 0.
	 * @param {Boolean} options.findingByText (optional) Identify whether finding data with field text, default is finding with field value
	 * @param {String} options.matchType (optional) The optional value: 'first' - match first, 'last' - match last, 'any' - match any, otherwise - match whole value.
	 * @param {String} options.extraFilter (optional) The extra filter when finding.
	 * 
	 * @return {Boolean} 
	 */
	findByField: function (fieldNameOrFieldArray, findingValue, options) {
		jslet.Checker.test('findByField#fieldNameOrFieldArray', fieldNameOrFieldArray).required();
		var Z = this;
		Z.confirm();
		var EQUAL = 1;
		function matchValue(matchType, value, findingValue) {
			if(jslet.compareValue(value, findingValue) === 0) {
				return EQUAL;
			}
			if(matchType == 'first') {
				return jslet.like(value, findingValue + '%');
			}
			if(matchType == 'any') {
				return jslet.like(value, '%' + findingValue + '%');
			}
			if(matchType == 'last') {
				return jslet.like(value, '%' + findingValue);
			}
			return 0;
		}
		var startRecno = 0,
			findingByText = false,
			matchType = null,
			extraFilter = null,
			extraFilterEval = null;
			
		if(options) {
			startRecno = options.startRecno || 0;
			findingByText = options.findingByText || false;
			matchType = options.matchType || null;
			extraFilter = options.extraFilter || null;
			if(extraFilter) {
				extraFilterEval = new jslet.data.Expression(Z, extraFilter);
			}
		}
		var records = Z._ignoreFilter? Z.records(): Z.filteredRecords();
		if(!records || records.length === 0) {
			return false;
		}
		
		var fields = fieldNameOrFieldArray;
		if(jslet.isString(fieldNameOrFieldArray)) {
			fields = fieldNameOrFieldArray.split(',');
		}
		var byTextArray = [], i,
			fldCnt = fields.length,
			fldName, fldObj;
		for(i = 0; i &lt; fldCnt; i++) {
			fldName = fields[i];
			fldObj = Z.getField(fldName);
			if(!fldObj) {
				throw new Error(jslet.formatMessage(jsletlocale.Dataset.fieldNotFound, [fldName]));
			}
			var byText = true;
			if(fldObj.getType() === 'N' &amp;&amp; !fldObj.lookup()) {
				byText = false;
			}
			byTextArray[i] = byText;
		}
		var start = !Z._ignoreFilter &amp;&amp; startRecno? startRecno: 0;
		var dataRec, foundRecno = -1, value, len, result = false, found = false;
		for(i = start, len = records.length; i &lt; len; i++) {
			dataRec = records[i];
			if(extraFilterEval &amp;&amp; !extraFilterEval.eval(dataRec)) {
				continue;
			}
			for(var j = 0; j &lt; fldCnt; j++) {
				fldName = fields[j];
				if(findingByText &amp;&amp; byTextArray[j]) {
					value = Z.getFieldTextByRecord(dataRec, fldName);
				} else {
					value = Z.getFieldValueByRecord(dataRec, fldName);
				}
				found = matchValue(matchType, value, findingValue);
				if (found) {
					foundRecno = i;
					if(Z._ignoreFilter) { // Only used in value converting, so does not need to move cursor.
						Z._ignoreFilterRecno = i;
						return true;
					}
					result = {};
					result.field = fldName;
					result.isEqual = (found === EQUAL);
					break;
				}
			}
			if(foundRecno &gt;= 0) {
				break;
			}
		}
		if (foundRecno &gt;= 0) {// can fire scroll event
			Z._gotoRecno(foundRecno);
			return result;
		}
		return false;
	},

<span id='jslet-data-Dataset-method-findByKey'>	/**
</span>	 * Find record with key value.
	 * &lt;br /&gt;Key value is field value of key field, and key field is defined by property {@link jslet.data.Dataset#keyField}.
	 * 
	 * @param {Object} keyValue Key value.
	 * 
	 * @return {Boolean}
	 */
	findByKey: function (keyValue) {
		var keyField = this.keyField();
		if (!keyField) {
			return false;
		}
		return this.findByField(keyField, keyValue);
	},

<span id='jslet-data-Dataset-method-lookup'>	/**
</span>	 * Find record and return the specified field value.
	 * 
	 *     @example
	 *     dsObj.lookup('department', 23, 'address'); // find department which id is 23, if found, return its address.
	 * 
	 * @param {String} fldName Field name.
	 * @param {Object} findingValue Finding field value.
	 * @param {String} returnFieldName Return value field name.
	 * 
	 * @return {Object} Field value.
	 */
	lookup: function (fldName, findingValue, returnFieldName) {
		jslet.Checker.test('lookup#fldName', fldName).required().isString();
		jslet.Checker.test('lookup#returnFieldName', returnFieldName).required().isString();
		
		if(fldName == returnFieldName) {
			return findingValue;
		}
		if (this.findByField(fldName, findingValue)) {
			return this.getFieldValue(returnFieldName);
		} else {
			return null;
		}
	},

<span id='jslet-data-Dataset-method-lookupByKey'>	/**
</span>	 * Find record with key value and return the specified field value.
	 * &lt;br /&gt;Key value is field value of key field, and key field is defined by property {@link jslet.data.Dataset#keyField}.
	 * 
	 *     @example
	 *     dsObj.lookupByKey(23, 'address'); // find department which id is 23, if found, return its address.
	 * 
	 * @param {Object} keyValue Key value
	 * @param {String} returnFieldName Return value field name.
	 * 
	 * @return {Object} Field value.
	 */
	lookupByKey: function(keyValue, returnFldName) {
		if (this.findByKey(keyValue)) {
			return this.getFieldValue(returnFldName);
		} else {
			return null;
		}
	},
	
<span id='jslet-data-Dataset-method-inChildrenAndSelf'>	/**
</span>	 * Check whether the field value of 'fldName' is the parent value or one of the children of 'parentValue'.
	 * 
	 * @param {String} fldname Field name which is checking, this field must connect a 'tree-style' dataset.
	 * @param {Object} parentValue The value which to be checked.
	 * @param {Boolean} onlyDirectChildren True - only the direct children to be used to check, false - otherwise.
	 * 
	 * @return {Boolean} True - the field value of current record is one of the children of the 'parentValue', false -otherwise.
	 */
	inChildrenAndSelf: function(fldName, parentValue, onlyDirectChildren) {
		jslet.Checker.test('inchildren#fldName', fldName).required().isString();
		jslet.Checker.test('inchildren#parentValue', parentValue).required();
		var fldValue = this.getFieldValue(fldName);
		if(jslet.compareValue(fldValue, parentValue) === 0) {
			return true;
		}
		return this.inChildren(fldName, parentValue, onlyDirectChildren);
	},
	
<span id='jslet-data-Dataset-method-inChildren'>	/**
</span>	 * Check whether the field value of 'fldName' is one of the children of 'parentValue' or not.
	 * 
	 * @param {String} fldname Field name which is checking, this field must connect a 'tree-style' dataset;
	 * @param {Object} parentValue The value which is used to check;
	 * @param {Boolean} onlyDirectChildren True - only the direct children to be used to check, false - otherwise.
	 * 
	 * @return {Boolean} True - the field value of current record is one of the children of the 'parentValue', false -otherwise.
	 */
	inChildren: function(fldName, parentValue, onlyDirectChildren) {
		jslet.Checker.test('inchildren#fldName', fldName).required().isString();
		jslet.Checker.test('inchildren#parentValue', parentValue).required();
		var Z = this,
			fldObj = Z.getField(fldName);
		if(!fldObj) {
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.fieldNotFound, [fldName]));
		}
		var lookup = fldObj.lookup();
		if(!lookup) {
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.lookupFieldExpected, [fldName]));
		}
		var lkds = lookup.dataset();
		jslet.Checker.test('inchildren#lookupDataset', lkds).required();
		jslet.Checker.test('inchildren#lookupDataset.parentField', lkds.parentField()).required();
		if(!lkds.findByKey(parentValue)) {
			return false;
		}
		var fldValue = Z.getFieldValue(fldName);
		var found = false;
		lkds.iterateChildren(function(isDirectChild) {
			var breakIterator = false;
			if(!onlyDirectChildren || (onlyDirectChildren &amp;&amp; isDirectChild)) {
				if(jslet.compareValue(lkds.keyValue(), fldValue) === 0) {
					breakIterator = true;
					found = true;
				}
			}
			return breakIterator;
		});
		return found;
	},

<span id='jslet-data-Dataset-method-copyDataset'>	/**
</span>	 * Copy dataset's data. Example:
	 * 
	 *     @example
	 *     dsObj.copyDataset(true); //return filtered records
	 *     dsObj.copyDataset(); //return all records
	 * 
	 * @param {Boolean} baseOnCurrentFilter If true, copy data base on the dataset's filter.
	 * 
	 * @return {Object[]} Array of records. 
	 */
	copyDataset: function (underCurrentFilter) {
		var Z = this;
		if (Z.recordCount() === 0) {
			return null;
		}
		var result = [];

		if ((!underCurrentFilter || !Z._filtered)) {
			return Z.records().slice(0);
		}

		var foundRecno = -1, 
			oldRecno = Z._recno, 
			oldFiltered = Z._filtered;
		if (!underCurrentFilter) {
			Z._filtered = false;
		}

		Z._silence++;
		try {
			Z.first();
			while (!Z.isEof()) {
				result.push(Z.getRecord());
				Z.next();
			}
		} finally {
			Z._silence--;
			Z._recno = oldRecno;
			if (!underCurrentFilter) {
				Z._filtered = oldFiltered;
			}
		}
		return result;
	},

<span id='jslet-data-Dataset-property-keyField'>	/**
</span>	 * @property
	 * 
	 * Set or get 'key' field name. Example:
	 * 
	 *     @example
	 *     dsObj.keyField('deptId'); //Set property, return this.
	 *     var propValue = dsObj.keyField(); //Get property value.
	 * 
	 * @param {String | undefined} keyFldName Key field name.
	 * @return {this | String}
	 */
	keyField: function (keyFldName) {
		if (keyFldName === undefined) {
			return this._keyField;
		}
		jslet.Checker.test('Dataset.keyField', keyFldName).isString();
		this._keyField = keyFldName? jslet.trim(keyFldName): null;
		return this;
	},

<span id='jslet-data-Dataset-property-codeField'>	/**
</span>	 * @property
	 * 
	 * Set or get 'code' field name. Example:
	 * 
	 *     @example
	 *     dsObj.codeField('deptCode'); //Set property, return this.
	 *     var propValue = dsObj.codeField(); //Get property value.
	 * 
	 * @param {String | undefined} codeFldName Code field name.
	 * @return {this | String}
	 */
	codeField: function (codeFldName) {
		if (codeFldName === undefined) {
			return this._codeField || this.keyField();
		}
		
		jslet.Checker.test('Dataset.codeField', codeFldName).isString();
		this._codeField = codeFldName? jslet.trim(codeFldName): null;
		return this;
	},
	
<span id='jslet-data-Dataset-property-nameField'>	/**
</span>	 * @property
	 * 
	 * Set or get 'name' field name. Example:
	 * 
	 *     @example
	 *     dsObj.nameField('deptName'); //Set property, return this.
	 *     var propValue = dsObj.nameField(); //Get property value.
	 * 
	 * @param {String | undefined} nameFldName 'Name' field name.
	 * @return {this | String}
	 */
	nameField: function (nameFldName) {
		if (nameFldName === undefined) {
			return this._nameField || this.codeField();
		}
		
		jslet.Checker.test('Dataset.nameField', nameFldName).isString();
		this._nameField = nameFldName? jslet.trim(nameFldName): null;
		return this;
	},

<span id='jslet-data-Dataset-property-parentField'>	/**
</span>	 * @property
	 * 
	 * Set or get 'parent' field name, this perperty is only used for hierarchy(tree-style) dataset. Example:
	 * 
	 *     @example
	 *     dsObj.parentField('deptName'); //Set property, return this.
	 *     var propValue = dsObj.parentField(); //Get property value.
	 * 
	 * @param {String | undefined} parentFldName Parent field name.
	 * @return {this | String}
	 */
	parentField: function (parentFldName) {
		if (parentFldName === undefined) {
			return this._parentField;
		}
		
		jslet.Checker.test('Dataset.parentField', parentFldName).isString();
		this._parentField = parentFldName? jslet.trim(parentFldName): null;
		return this;
	},
	
<span id='jslet-data-Dataset-property-levelOrderField'>	/**
</span>	 * @property
	 * 
	 * Set or get level order field name, this perperty is only used for hierarchy(tree-style) dataset. Example:
	 * 
	 *     @example
	 *     dsObj.levelOrderField('levelOrder'); //Set property, return this.
	 *     var propValue = dsObj.levelOrderField(); //Get property value.
	 * 
	 * @param {String | undefined} fldName Level order field name.
	 * @return {this | String}
	 */
	levelOrderField: function(fldName) {
		if (fldName === undefined) {
			return this._levelOrderField;
		}
		
		jslet.Checker.test('Dataset.levelOrderField', fldName).isString();
		this._levelOrderField = fldName? jslet.trim(fldName): null;
		return this;
	},
	
<span id='jslet-data-Dataset-property-selectField'>	/**
</span>	 * @property
	 * 
	 * Set or get 'select' field name. &quot;Select field&quot; is a field to store the selected state of a record. Example:
	 * 
	 *     @example
	 *     dsObj.selectField('levelOrder'); //Set property, return this.
	 *     var propValue = dsObj.selectField(); //Get property value.
	 * 
	 * @param {String} selectFldName - Select field name.
	 * @return {this | String}
	 */
	selectField: function (selectFldName) {
		if (selectFldName === undefined) {
			return this._selectField ;
		}
		
		jslet.Checker.test('Dataset.selectField', selectFldName).isString();
		this._selectField = selectFldName? jslet.trim(selectFldName): null;
		return this;
	},
	
<span id='jslet-data-Dataset-property-statusField'>	/**
</span>	 * @property
	 * 
	 * Set or get 'status' field name. &quot;Status field&quot; is a field to store the status of a record.
	 * It's usually used for disabled or enabled of a record. Example:
	 * 
	 *     @example
	 *     dsObj.statusField('levelOrder'); //Set property, return this.
	 *     var propValue = dsObj.statusField(); //Get property value.
	 * 
	 * @param {String} statusFldName Status field name.
	 * @return {this | String}
	 */
	statusField: function (statusFldName) {
		if (statusFldName === undefined) {
			return this._statusField;
		}
		
		jslet.Checker.test('Dataset.statusField', statusFldName).isString();
		this._statusField = statusFldName? jslet.trim(statusFldName): null;
		return this;
	},
	
<span id='jslet-data-Dataset-property-contextRules'>	/**
</span>	 * @property
	 * 
	 * Set or get context rules.
	 * 
	 * @param {jslet.data.ContextRule[] | undefined} contextRule Context rule.
	 * @return {this | jslet.data.ContextRule[]}
	 */
	contextRules: function (rules) {
		var Z = this;
		if (rules === undefined) {
			return Z._contextRules;
		}
		if(jslet.isString(rules)) {
			rules = rules? jslet.JSON.parse(rules): null;
		}
		jslet.Checker.test('Dataset.contextRules', rules).isArray();
		if(!rules || rules.length === 0) {
			Z._contextRules = null;
			Z._contextRuleEngine = null;
		} else {
			var ruleObj;
			for(var i = 0, len = rules.length; i &lt; len; i++) {
				ruleObj = rules[i];
				if(!ruleObj.className || 
						ruleObj.className != jslet.data.ContextRule.className) {
					
					rules[i] = new jslet.data.ContextRule(ruleObj);
				}
			}
			Z._contextRules = rules;
			Z._contextRuleEngine = new jslet.data.ContextRuleEngine(Z);
			Z._contextRuleEngine.compile();
			Z.enableContextRule();
		}
		return this;
	},
	
<span id='jslet-data-Dataset-method-disableContextRule'>	/**
</span>	 * Disable context rule.
	 * 
	 * @return {this}
	 */
	disableContextRule: function () {
		this._contextRuleEnabled = false;
//		this.restoreContextRule();
		return this;
	},

<span id='jslet-data-Dataset-method-enableContextRule'>	/**
</span>	 * Enable context rule, any context rule will be calculated.
	 * 
	 * @return {this}
	 */
	enableContextRule: function () {
		this._contextRuleEnabled = true;
		this.calcContextRule();
		return this;
	},

<span id='jslet-data-Dataset-method-isContextRuleEnabled'>	/**
</span>	 * Check whether context rule is enabled or not.
	 * 
	 * @return {Boolean}
	 */
	isContextRuleEnabled: function () {
		return this._contextRuleEnabled;
	},

<span id='jslet-data-Dataset-method-calcContextRule'>	/**
</span>	 * @private
	 */
	calcContextRule: function (changedField) {
		var Z = this;
		if(!Z._contextRuleEnabled || Z.recordCount() === 0) {
			return;
		}
		
		if(Z._contextRuleEngine) {
			Z._inContextRule = true;
			try {
				Z._contextRuleEngine.evalRule(changedField);
			} finally {
				Z._inContextRule = false;
			}
		}
	},

<span id='jslet-data-Dataset-method-_refreshProxyField'>	/**
</span>	 * @private
	 */
	_refreshProxyField: function(dataRecord, isSilence) {
		var Z = this;
		if(!Z._proxyFields || Z.recordCount() === 0) {
			return;
		}
		if(!dataRecord) {
			dataRecord = Z.getRecord();
		}

		var fldObj;
		for(var i = 0, len = Z._proxyFields.length; i &lt; len; i++) {
			fldObj = Z._proxyFields[i];
			fldObj.changeProxyFieldName(dataRecord, isSilence);
		}
	},
	

<span id='jslet-data-Dataset-method-checkSelectable'>	/**
</span>	 * Check current record whether it's selectable.
	 * 
	 * @return {Boolean}
	 */
	checkSelectable: function (recno) {
		if(this.recordCount() === 0) {
			return false;
		}
		if(this._onCheckSelectable) {
			var eventFunc = jslet.getFunction(this._onCheckSelectable);
			if(eventFunc) {
				return eventFunc.call(this, recno);
			}
		}
		return true;
	},
	
<span id='jslet-data-Dataset-property-selected'>	/**
</span>	 * @property
	 * 
	 * Set or get selected state of current record. Example:
	 * 
	 *     @example
	 *     dsObj.selected(true); //Set property, return this.
	 *     var propValue = dsObj.selected(); //Get property value.
	 * 
	 * @param {Boolean | undefined} selected.
	 * 
	 * @return {this | Boolean}
	 */
	selected: function (selected) {
		var Z = this;
		var selFld = Z._selectField || jslet.global.selectStateField,
			rec = Z.getRecord();
		
		if(selected === undefined) {
			return rec &amp;&amp; rec[selFld];
		}
		
		if(rec) {
			if(Z.checkSelectable()) {
				Z._aborted = false;
				try {
					Z._fireDatasetEvent(jslet.data.DatasetEvent.BEFORESELECT);
					if (Z._aborted) {
						return Z;
					}
				} finally {
					Z._aborted = false;
				}
				rec[selFld] = selected;
				Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERSELECT);
				if(this._contextRuleEngine) {
					this._contextRuleEngine.evalRule();
				}
			}
		}
		return Z;
	},
	
<span id='jslet-data-Dataset-method-selectedByRecno'>	/**
</span>	 * Get selected state of specified record. Example:
	 * 
	 *     @example
	 *     dsObj.selected(true);
	 *     dsObj.selectedByRecno(); //return true
	 * 
	 * @param {Integer} recno (optional) Record number, if recno is not applied, return current record selected state.
	 * 
	 * @return {this | Boolean}
	 */
	selectedByRecno: function(recno) {
		var Z = this,
			selFld = Z._selectField || jslet.global.selectStateField,
			rec = Z.getRecord(recno);
		
		return rec &amp;&amp; rec[selFld];
	},
	
<span id='jslet-data-Dataset-method-selectAll'>	/**
</span>	 * Select / unselect all records.
	 * 
	 * @param {Boolean} selected True - select records, false otherwise.
	 * @param {Function} onSelectAll Select event handler.
	 * @param {jslet.data.Dataset} onSelectAll.dataset Current dataset.
	 * @param {Boolean} onSelectAll.selected True - select records, false otherwise.
	 * @param {Boolean} onSelectAll.return True - allow user to select, false - otherwise.
	 * @param {Boolean} noRefresh True - refresh controls, false - otherwise.
	 * 
	 * @return {this}
	 */
	selectAll: function (selected, onSelectAll, noRefresh) {
		var Z = this;
		if (Z.recordCount() === 0) {
			return this;
		}
		try {
			Z._fireDatasetEvent(jslet.data.DatasetEvent.BEFORESELECTALL);
			if (Z._aborted) {
				return this;
			}
		} finally {
			Z._aborted = false;
		}

		jslet.Checker.test('Dataset.selectAll#onSelectAll', onSelectAll).isFunction();
		var oldRecno = Z.recno();
		try {
			for (var i = 0, cnt = Z.recordCount(); i &lt; cnt; i++) {
				Z.recnoSilence(i);

				Z.selected(selected);
			}
		} finally {
			Z.recnoSilence(oldRecno);
		}
		if (onSelectAll) {
			onSelectAll(this, selected);
		}
		Z._fireDatasetEvent(jslet.data.DatasetEvent.AFTERSELECTALL);
		if (!noRefresh) {
			var evt = jslet.data.RefreshEvent.selectAllEvent(selected);
			Z.refreshControl(evt);
		}
		return this;
	},

<span id='jslet-data-Dataset-method-selectByKeyValue'>	/**
</span>	 * Select/unselect record by key value.
	 * 
	 * @param {Boolean} selected True - select records, false otherwise.
	 * @param {Object} keyValue Key value.
	 * @param {Boolean} noRefresh True - refresh controls, false - otherwise.
	 * 
	 * @return {this}
	 */
	selectByKeyValue: function (selected, keyValue, noRefresh) {
		var Z = this,
			oldRecno = Z.recno(),
			cnt = Z.recordCount(),
			v, changedRecNum = [];
		try {
			for (var i = 0; i &lt; cnt; i++) {
				Z.recnoSilence(i);
				v = Z.getFieldValue(Z._keyField);
				if (v == keyValue) {
					Z.selected(selected);
					changedRecNum.push(i);
					break;
				}
			} //end for
		} finally {
			Z.recnoSilence(oldRecno);
		}
		if (!noRefresh) {
			var evt = jslet.data.RefreshEvent.selectRecordEvent(changedRecNum, selected);
			Z.refreshControl(evt);
		}
		return this;
	},

<span id='jslet-data-Dataset-method-select'>	/**
</span>	 * Select current record or not.
	 * If 'selectBy' is not empty, select all records which value of 'selectBy' field is same as the current record. Example:
	 * 
	 *     @example
	 *     dsEmployee.select(true); //select current record
	 *     dsEmployee.select(true, 'gender'); //if the 'gender' of current value is female, all female employees will be selected.  
	 * 
	 * @param {Boolean} selected True - select records, false - unselect records.
	 * @param {String} selectBy Field names, multiple fields separated with ','.
	 * 
	 * @return {this}
	 */
	select: function (selected, selectBy) {
		var Z = this;
		if (Z.recordCount() === 0) {
			return this;
		}

		var changedRecNum = [];
		if (!selectBy) {
			Z.selected(selected);
			changedRecNum.push(Z.recno());
		} else {
			var arrFlds = selectBy.split(','), 
				arrValues = [], i, 
				fldCnt = arrFlds.length;
			for (i = 0; i &lt; fldCnt; i++) {
				arrValues[i] = Z.getFieldValue(arrFlds[i]);
			}
			var v, preRecno = Z.recno(), flag;
			try {
				for (var k = 0, recCnt = Z.recordCount(); k &lt; recCnt; k++) {
					Z.recnoSilence(k);
					flag = 1;
					for (i = 0; i &lt; fldCnt; i++) {
						v = Z.getFieldValue(arrFlds[i]);
						if (v != arrValues[i]) {
							flag = 0;
							break;
						}
					}
					if (flag) {
						Z.selected(selected);
						changedRecNum.push(Z.recno());
					}
				}
			} finally {
				Z.recnoSilence(preRecno);
			}
		}

		var evt = jslet.data.RefreshEvent.selectRecordEvent(changedRecNum, selected);
		Z.refreshControl(evt);
		return this;
	},

<span id='jslet-data-Dataset-property-dataProvider'>	/**
</span>	 * @property
	 * 
	 * Set or get data provider.
	 * 
	 * @param {jslet.data.DataProvider | undefined} provider Data provider
	 * @return {this | jslet.data.DataProvider}
	 */
	dataProvider: function (provider) {
		if (provider === undefined) {
			return this._dataProvider;
		}
		this._dataProvider = provider;
		return this;
	},
	
<span id='jslet-data-Dataset-method-_checkDataProvider'>	/**
</span>	 * @private
	 */
	_checkDataProvider: function () {
		if (!this._dataProvider) {
			throw new Error('DataProvider required, use: yourDataset.dataProvider(yourDataProvider);');
		}
	},

<span id='jslet-data-Dataset-method-selectedRecords'>	/**
</span>	 * Get all selected records
	 * 
	 * @return {Object[]} Array of records
	 */
	selectedRecords: function () {
		var Z = this;
		if (!Z.hasRecord()) {
			return null;
		}

		var preRecno = Z.recno(), result = [];
		try {
			for (var k = 0, recCnt = Z.recordCount(); k &lt; recCnt; k++) {
				Z.recnoSilence(k);
				if(Z.selected()) {
					result.push(Z.getRecord());
				}
			}
		} finally {
			Z.recnoSilence(preRecno);
		}
		
		return result;
	},

	hasSelectedRecords: function() {
		var Z = this, found = false;
		Z.iterate(function() {
			if(this.selected()) {
				found = true;
				return true;
			}
		});
		return found;
	},
	
<span id='jslet-data-Dataset-method-selectedKeyValues'>	/**
</span>	 * Get all key values of selected records.
	 * 
	 * @return {Object[]} Array of selected record key values
	 */
	selectedKeyValues: function () {
		var oldRecno = this.recno(), result = [];
		try {
			for (var i = 0, cnt = this.recordCount(); i &lt; cnt; i++) {
				this.recnoSilence(i);
				var state = this.selected();
				if (state &amp;&amp; state !== 2) { // 2: partial select
					result.push(this.getFieldValue(this._keyField));
				}
			}
		} finally {
			this.recnoSilence(oldRecno);
		}
		if (result.length &gt; 0) {
			return result;
		} else {
			return null;
		}
	},

<span id='jslet-data-Dataset-method-queryUrl'>	/**
</span>	 * Set or get query url. Example:
	 * 
	 *     @example
	 *     dsObj.queryUrl('/test/query.do'); //Set property, return this.
	 *     var propValue = dsObj.queryUrl(); //Get property value.
	 * 
	 * @param {String | undefined} queryUrl Query url.
	 * 
	 * @return {this | String}
	 */
	queryUrl: function(url) {
		if(url === undefined) {
			return this._queryUrl;
		}
		jslet.Checker.test('Dataset.queryUrl', url).isString();
		this._queryUrl = url? jslet.trim(url): null;
		return this;
	},
	
<span id='jslet-data-Dataset-method-query'>	/**
</span>	 * Query data from server. Example:
	 * 
	 *     @example
	 *     dsEmployee.queryUrl('../getemployee.do');
	 *     var criteria = {name:'Bob', age:25};
	 *     dsEmployee.query(condition).done(function() {
	 *     	 console.log('done');
	 *     });
	 * 
	 * @param {Object | jslet.data.Dataset} criteria Condition should be a plan object or a dataset which stores query criteria.
	 * 
	 * @return {Object} jQuery promise.
	 */
	query: function (criteria) {
		if(criteria &amp;&amp; criteria instanceof jslet.data.Dataset) {
			var criteriaDataset = criteria;
			criteriaDataset.confirm();
			if(criteriaDataset.checkAndShowError()) {
				return new jslet.EmptyPromise('fail');
			}
			criteria = criteriaDataset.getRecord();
		}
		this._queryCriteria = criteria;
		return this.requery();
	},

	_doQuerySuccess: function(result, dataset) {
		var Z = dataset;
		if (!result) {
			Z.records([]);
			if(result &amp;&amp; result.info) {
				jslet.showInfo(result.info);
			}
			return;
		}
		if(Z._onDataQuerying) {
			Z._onDataQuerying(result);
		}
		var metas = result.meta;
		if(metas &amp;&amp; metas.main) {
			Z._createDatasetByMeta(Z._name, metas.main);
		}
		var mainData = result.main;
		if (mainData) {
			Z.records(mainData);
		}
		var others = result.others;
		if(others) {
			var dsName, dsObj;
			for (dsName in others) {
				if(metas &amp;&amp; metas[dsName]) {
					Z._createDatasetByMeta(Z._name, metas[dsName]);
				}
				dsObj = jslet.data.getDataset(dsName);
				if (dsObj) {
					dsObj.records(others[dsName]);
				} else {
					console.warn(dsName + ' is returned from server, but this datase does not exist!');
				}
			}
		}
		if (result.pageNo) {
			Z._pageNo = result.pageNo;
		}
		if (result.pageCount) {
			Z._pageCount = result.pageCount;
		}
		if(Z._onDataQueried) {
			Z._onDataQueried.call(Z);
		}

		var evt = jslet.data.RefreshEvent.changePageEvent();
		Z.refreshControl(evt);
		if(result &amp;&amp; result.info) {
			jslet.showInfo(result.info);
		}
	},
	
	_createDatasetByMeta: function(dsName, dsMeta) {
		var dsObj = jslet.data.getDataset(dsName);
		var fields = dsMetaFields;
		if(!dsObj) {
			dsObj = new jslet.data.Dataset({name: dsName, fields: fields});
		} else {
			dsObj.clearFields();
			var fldCfg;
			for(var i = 0, len = fields.length; i &lt; len; i++) {
				fldCfg = fields[i];
				dsObj.createField(fldCfg);
			}
		}
	},
	
	_doApplyError: function(result, dataset) {
		var Z = dataset,
			errCode = result.errorCode,
			errMsg = result.errorMessage;
		if(jslet.global.serverErrorHandler) {
			var catched = jslet.global.serverErrorHandler(errCode, errMsg);
			if(catched) {
				return;
			}
		}
		errMsg = errMsg + &quot;[&quot; + errCode + &quot;]&quot;;
		Z.errorMessage(errMsg);
		if(Z._autoShowError) {
			jslet.showError(errMsg);
		}
	},
	
<span id='jslet-data-Dataset-method-requery'>	/**
</span>	 * Send request to refresh with current condition.
	 * 
	 * @return {Object} jQuery promise.
	 */
	requery: function () {
		var Z = this;
		Z._checkDataProvider();

		if(!this._queryUrl) {
			//QueryUrl required! Use: yourDataset.queryUrl(yourUrl)
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.queryUrlRequired, [Z.description()]));
			
		}
		if(Z._querying) { //Avoid duplicate submitting
			return;
		}
		Z._querying = true;
		try {
			var reqData = {};
			if(Z._pageNo &gt; 0) {
				reqData.pageNo = Z._pageNo;
				reqData.pageSize = Z._pageSize;
			}
			var criteria = Z._queryCriteria;
			if(criteria) {
				if(jslet.isArray(criteria)) {
					reqData.criteria = criteria;
				} else {
					reqData.simpleCriteria = criteria;
				}
			}
			reqData = jslet.data.record2Json(reqData);
			var url = Z._queryUrl;
			return Z._dataProvider.sendRequest(Z, url, reqData)
			.done(Z._doQuerySuccess)
			.fail(Z._doApplyError)
			.always(function(){Z._querying = false;});
		} catch(e) {
			Z._querying = false;
		}
	},

	_setChangedState: function(flag, chgRecs, pendingRecs) {
		if(!chgRecs || chgRecs.length === 0) {
			return;
		}
		var result = this._addRecordClassFlag(chgRecs, flag, this._recordClass || jslet.global.defaultRecordClass);
		for(var i = 0, len = result.length; i &lt; len; i++) {
			pendingRecs.push(result[i]);
		}
	},

	_addRecordClassFlag: function(records, changeFlag, recClazz) {
		var fields = this.getFields(),
			fldObj, i, len, 
			detailRecordClass = null;
		
		for(i = 0, len = fields.length; i &lt; len; i++) {
			fldObj = fields[i];
			if(fldObj.getType() === jslet.data.DataType.DATASET) {
				if(!detailRecordClass) {
					detailRecordClass = {};
				}
				detailRecordClass[fldObj.name()] = fldObj.detailDataset().recordClass();
			}
		}
		var result = [], rec, pRec, dtlRecClazz, cnt;
		for (i = 0, cnt = records.length; i &lt; cnt; i++) {
			rec = records[i];
			pRec = {};
			rec[jslet.global.changeStateField] = changeFlag + i;
			var fldValue;
			for(var prop in rec) {
				fldValue = rec[prop];
				if(fldValue &amp;&amp; detailRecordClass) {
					dtlRecClazz = detailRecordClass[prop];
					if(dtlRecClazz) {
						fldValue = this._addRecordClassFlag(fldValue, changeFlag, dtlRecClazz);
					}
				}
				pRec[prop] = fldValue;
			}
			result.push(pRec);
		}
		return result;
	},
	
	_doSaveSuccess: function(result, dataset) {
		var Z = dataset,
			changedRecs, 
			needCalc = false;
		if (!result || !result.main || result.main.length === 0) {
			changedRecs = Z._pendingRecords;
		} else {
			changedRecs = result.main;
			needCalc = true;
		}
		Z._dataTransformer.refreshSubmittedData(changedRecs);
		if(needCalc) {
			Z._calcAggregatedValueDebounce.call(Z);
		}
		Z.selection.removeAll();
		if(Z._onDataSubmitted) {
			Z._onDataSubmitted.call(Z);
		}
		
		Z.refreshControl();
		Z.refreshLookupHostDataset();
		if(result &amp;&amp; result.info) {
			jslet.showInfo(result.info);
		}
	},
	
<span id='jslet-data-Dataset-method-submitUrl'>	/**
</span>	 * Set or get submit url. Example:
	 * 
	 *     @example
	 *     dsObj.submitUrl('/test/save.do'); //Set property, return this.
	 *     var propValue = dsObj.submitUrl(); //Get property value.
	 * 
	 * @param {String | undefined} submitUrl Submit url.
	 * 
	 * @return {this | String}
	 */
	submitUrl: function(url) {
		if(url === undefined) {
			return this._submitUrl;
		}

		jslet.Checker.test('Dataset.submitUrl', url).isString();
		this._submitUrl = url? jslet.trim(url): null;
		return this;
	},
	
<span id='jslet-data-Dataset-method-hasChangedData'>	/**
</span>	 * Check whether dataset exists changed records.
	 * 
	 * @return {Boolean}
	 */
	hasChangedData: function(noConfirm) {
		var Z = this;
		if(!noConfirm) {
			Z.confirm();
		}
		var records = Z.records(), record, recInfo;
		if(!records) {
			return false;
		}
		for(var i = 0, len = records.length; i &lt; len; i++) {
			record = records[i];
			if(Z.recordChanged(record)) {
				return true;
			}
		}
		return false;
	},
	
	recordChanged: function(record) {
		if(!record) {
			return false;
		}
		var recInfo = jslet.data.getRecInfo(record);
		if(recInfo &amp;&amp; recInfo.status &amp;&amp; recInfo.status !== jslet.data.DataSetStatus.BROWSE) {
			return true;
		}
		return false;
	},
	
<span id='jslet-data-Dataset-method-submit'>	/**
</span>	 * Submit changed data to server. 
	 * If server side save data successfully and return the changed data, Jslet can refresh the local data automatically.
	 * 
	 * Cause key value is probably generated at server side(like sequence), we need an extra field which store an unique value to update the key value,
	 * this extra field is named by global variable: jslet.global.changeStateField(default is'rs'), its value will start a letter 'i', 'u' or 'd', and follow a random number.
	 * You don't care about it in client side, it is generated by Jslet automatically.
	 * 
	 * At server side, you can use the leading letter to distinguish which action will be sent to DB('i' for insert, 'u' for update and 'd' for delete)
	 * If the records need be changed in server(like sequence key or other calculated fields), you should return them back.Notice:
	 * you need not to change this value of extra field: '_s_', just return it. Example:
	 * 
	 *     @example
	 *     dsObj.insertRecord();
	 *     dsObj.setFieldValue('name','Bob');
	 *     dsObj.setFieldValue('code','A01');
	 *     dsObj.confirm();
	 *     dsObj.submitUrl('../save.do');
	 *     dsObj.submit().done(function() {
	 *       console.log('done'); 
	 *     });
	 * 
	 * @param {Object} extraData extraData to submit to server
	 * @param {Object} options Options.
	 * @param {jslet.data.RecordRange} options.range Record range, the default value is jslet.data.RecordRange.SELECTED
	 * @param {String[]} options.includeFields Array of field names which need be submitted to server;
	 * @param {String[]} options.excludeFields Array of field names which need not be submitted to server;
	 * @param {jslet.data.RecordRange | Object} options.detailRange For detail dataset the default record range is jslet.data.RecordRange.ALL.&lt;br /&gt;
	 * 		if detailRange is a value of jslet.data.RecordRange, all detail dataset has the same record range. &lt;br /&gt;
	 *      if detailRange is a object value, the value pattern is: {detailDatasetName: jslet.data.RecordRange}
	 * 
	 * @return {Object} jQuery promise.
	 */
	submit: function(extraData, options) {
		return this._innerSubmit(extraData, options);
	},
	
<span id='jslet-data-Dataset-method-submitDeleted'>	/**
</span>	 * Submit deleted data to server. 
	 * 
	 * @param {Object} extraData extraData to submit to server
	 * 
	 * @return {Object} jQuery promise.
	 */
	submitDeleted: function(extraData) {
		return this._innerSubmit(extraData, options, true);		
	},
	
	_innerSubmit: function(extraData, options, onlyDeleted) {
		var Z = this;
		var range = options &amp;&amp; options.range,
			includeFields = options &amp;&amp; options.includeFields,
			excludeFields = options &amp;&amp; options.excludeFields;
		Z.confirm();
		if(Z.checkAndShowError(includeFields, excludeFields, range)) {
			return new jslet.EmptyPromise('fail');
		}
		Z._checkDataProvider();

		if(!Z._submitUrl) {
			//Dataset\'s submitUrl required! Use: yourDataset.submitUrl(yourUrl)
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.submitUrlRequired, [Z.description()]));
		}
		
		var	detailRange = options &amp;&amp; options.detailRange;
		var changedRecs = Z._dataTransformer.getSubmittingChanged(range, detailRange);
		if(changedRecs &amp;&amp; onlyDeleted) {
			for(var i = changedRecs.length - 1; i &gt;= 0; i--) {
				if('d' !== changedRecs[i].rs[0]) {
					changedRecs.splice(i, 1);
				}
			}
		}
		if (!changedRecs || changedRecs.length === 0) {
			jslet.showInfo(jsletlocale.Dataset.noDataSubmit);
			return new jslet.EmptyPromise('fail');
		}
		if(Z._submitting) { //Avoid duplicate submitting
			return;
		}
		Z._submitting = true;
		try {
			var reqData = {},
				dsName = Z.name();
			reqData.mainName = dsName;
			reqData.main = changedRecs;
			var dataMetas = {};
			reqData.meta = dataMetas;
			Z._getSubmitMeta(Z, dataMetas, 'main');
			
			if(extraData) {
				reqData.extraData = extraData;
			}
			Z._pendingRecords = changedRecs;
			reqData = jslet.data.record2Json(reqData, Z._getExcludeFields(includeFields, excludeFields));
			var url = Z._submitUrl;
			return Z._dataProvider.sendRequest(Z, url, reqData)
			.done(Z._doSaveSuccess)
			.fail(Z._doApplyError)
			.always(function(){
				Z._submitting = false;
				Z._pendingRecords = null;
			});
		} catch(e) {
			console.error(e);
			Z._submitting = false;
			Z._pendingRecords = null;
		}
	},
	
	_getSubmitMeta: function(dsObj, dataMetas, dsName) {
		var Z = this,
			fields = [], fldObj,
			dataMeta = {fields: fields},
			fldMeta, dataType,
			clazzName = Z.recordClass();
		if(clazzName) {
			dataMeta.recordClass = clazzName;
		}
		if(!dsName) {
			dsName = dsObj.name();
		}
		dataMetas[dsName] = dataMeta;
		var fldList = dsObj._fields;
		for(var i = 0, len = fldList.length; i &lt; len; i++) {
			fldObj = fldList[i];
			dataType = fldObj.dataType();
			if(dataType === jslet.data.DataType.DATE) {
				fldMeta = {name: fldObj.name(), dataType: dataType};
				fields.push(fldMeta);
				continue;
			}
			if(dataType === jslet.data.DataType.DATASET) {
				fldMeta = {name: fldObj.name(), dataType: dataType};
				var dsDetail = fldObj.detailDataset();
				fldMeta.detailDataset = dsDetail.name();
				Z._getSubmitMeta(dsDetail, dataMeta);
				fields.push(fldMeta);
				continue;
			}
		}
	},
	
	_doSubmitSelectedSuccess: function(result, dataset) {
		if(!result) {
			return;
		}
		var mainData = result.main;
		if (!mainData || mainData.length === 0) {
			if(result.info) {
				jslet.showInfo(result.info);
			}
			return;
		}
		var Z = dataset,
			deleteOnSuccess = Z._deleteOnSuccess_,
			arrRecs = Z.selectedRecords() || [],
			i, k, rec,
			records = Z.records();
		Z.selection.removeAll();
		if(deleteOnSuccess) {
			for(i = arrRecs.length; i &gt;= 0; i--) {
				rec = arrRecs[i];
				k = records.indexOf(rec);
				records.splice(k, 1);
			}
			Z._refreshInnerRecno();
		} else {
			var newRec, oldRec, len;
			Z._dataTransformer.refreshSubmittedData(mainData);
		}
		Z._calcAggregatedValueDebounce.call(Z);
		if(Z._onDataSubmitted) {
			Z._onDataSubmitted.call(Z);
		}
		Z.refreshControl();
		Z.refreshLookupHostDataset();
		if(result &amp;&amp; result.info) {
			jslet.showInfo(result.info);
		}
	},
	
<span id='jslet-data-Dataset-method-submitSelected'>	/**
</span>	 * Send selected data to server whether or not the records have been changed. 
	 * Under some special scenarios, we need send user selected record to server to process. 
	 * Sever side need not send back the processed records. Example:
	 * 
	 *     @example
	 *     //Audit the selected records, if successful, delete the selected records.
	 *     dsObj.selectAll(true);
	 *     var options = {deleteOnSuccess: true};
	 *     dsObj.submitSelected('../audit.do', null, options);
	 *     
	 *     //Submit all records
	 *     options = {range: jslet.data.RecordRange.ALL};
	 *     dsObj.submitSelected('../audit.do', null, options);
	 *      
	 *     //Submit the current record
	 *     options = {range: jslet.data.RecordRange.CURRENT};
	 *     dsObj.submitSelected('../audit.do', null, options);
	 *      
	 *     //Submit the current record width included fields
	 *     options = {range: jslet.data.RecordRange.CURRENT,
	 *     			  includeFields: ['id', 'name']};
	 *     dsObj.submitSelected('../audit.do', null, options);
	 *      
	 *     //Set all detail datasets' record range
	 *     options = {detailRange: jslet.data.RecordRange.SELECTED};
	 *     dsObj.submitSelected('../audit.do', null, options);
	 *      
	 *     //Set some detail datasets' record range
	 *     //Assume the dataset has two detail dataset, named: 'dtlDsName1' and 'dtlDsName2'
	 *     options = {detailRange: {dtlDsName1: jslet.data.RecordRange.SELECTED, dtlDsName2: jslet.data.RecordRange.ALL};
	 *     dsObj.submitSelected('../audit.do', null, options);
	 * 
	 * @param {String} url Submitting URL.
	 * @param {Object} extraData extraData to submit to server
	 * @param {Object} options Options.
	 * @param {jslet.data.RecordRange} options.range Record range, the default value is jslet.data.RecordRange.SELECTED
	 * @param {Boolean} options.deleteOnSuccess If processing successfully at server side, delete the selected record or not.
	 * @param {Boolean} options.submitEmpty True - submit to server even user does not select records, false - (Default) stop submitting if not selecting any records.
	 * @param {String[]} options.includeFields Array of field names which need be submitted to server;
	 * @param {String[]} options.excludeFields Array of field names which need not be submitted to server;
	 * @param {jslet.data.RecordRange | Object} options.detailRange For detail dataset the default record range is jslet.data.RecordRange.ALL.&lt;br /&gt;
	 * 		if detailRange is a value of jslet.data.RecordRange, all detail dataset has the same record range. &lt;br /&gt;
	 *      if detailRange is a object value, the value pattern is: {detailDatasetName: jslet.data.RecordRange}
	 * 
	 */
	submitSelected: function (url, extraData, options) {
		var Z = this;
		Z.confirm();
		var range = options &amp;&amp; options.range,
			includeFields = options &amp;&amp; options.includeFields,
			excludeFields = options &amp;&amp; options.excludeFields,
			submitEmpty = options &amp;&amp; options.submitEmpty;
		if(range === undefined) {
			range = jslet.data.RecordRange.SELECTED;
		}
		if(Z.checkAndShowError(includeFields, excludeFields, range)) {
			return new jslet.EmptyPromise('fail');
		}
		Z._checkDataProvider();
		jslet.Checker.test('Dataset.submitSelected#url', url).required().isString();
		if(Z._submitting) { //Avoid duplicate submitting
			return;
		}
		Z._submitting = true;
		var deleteOnSuccess = options &amp;&amp; options.deleteOnSuccess? true: false,
			detailRange = options &amp;&amp; options.detailRange;
		try {
			var changedRecs = Z._dataTransformer.getSubmittingSelected(range, detailRange) || [];
			if (!submitEmpty &amp;&amp; (!changedRecs || changedRecs.length === 0)) {
				jslet.showInfo(jsletlocale.Dataset.noDataSubmit);
				return new jslet.EmptyPromise('fail');
			}
	
			Z._deleteOnSuccess_ = deleteOnSuccess;
			
			var reqData = {},
				dsName = Z.name();
			reqData.mainName = dsName;
			reqData.main = changedRecs;
			var dataMetas = {};
			reqData.meta = dataMetas;
			Z._getSubmitMeta(Z, dataMetas, 'main');
			
			if(extraData) {
				reqData.extraData = extraData;
			}
			reqData = jslet.data.record2Json(reqData, Z._getExcludeFields(includeFields, excludeFields));
			console.log(reqData);
			return Z._dataProvider.sendRequest(Z, url, reqData)
			.done(Z._doSubmitSelectedSuccess)
			.fail(Z._doApplyError)
			.always(function(){
				Z._submitting = false;
			});
		} catch(e) {
			Z._submitting = false;
		}
	},

	_getExcludeFields: function(includeFields, excludeFields) {
		if(!includeFields || includeFields.length === 0) {
			return excludeFields || null;
		}
		var Z = this;
		var fields = Z.getNormalFields(), fldObj, fldName;
		var result = [], i, len;
		for(var i = 0, len = fields.length; i &lt; len; i++) {
			fldName = fldObj.name();
			if(includeFields.indexOf(fldName) &lt; 0) {
				result.push(fldName);
			}
		}
		if(excludeFields) {
			for(i = 0, len = excludeFields.length; i &lt; len; i++) {
				fldName = excludeFields[i];
				if(exFields.indexOf(fldName) &lt; 0) {
					result.push(fldName);
				}
			}
		}
		return result;
	},
	
<span id='jslet-data-Dataset-method-_refreshInnerControl'>	/**
</span>	 * @private
	 */
	_refreshInnerControl: function (updateEvt) {
		var i, cnt, ctrl;
		if (updateEvt.eventType == jslet.data.RefreshEvent.UPDATEALL || 
				updateEvt.eventType == jslet.data.RefreshEvent.CHANGEMETA) {
			cnt = this._linkedLabels? this._linkedLabels.length: 0;
			for (i = 0; i &lt; cnt; i++) {
				ctrl = this._linkedLabels[i];
				if (ctrl.refreshControl) {
					ctrl.refreshControl(updateEvt);
				}
			}
		}
		cnt = this._linkedControls? this._linkedControls.length: 0;
		for (i = 0; i &lt; cnt; i++) {
			ctrl = this._linkedControls[i];
			if (ctrl &amp;&amp; ctrl.refreshControl) {
				ctrl.refreshControl(updateEvt);
			}
		}
	},

<span id='jslet-data-Dataset-method-focusEditControl'>	/**
</span>	 * Focus on the edit control that link specified field name.
	 * 
	 * @param {String} fldName Field name.
	 * 
	 * @return {this}
	 */
	focusEditControl: function (fldName) {
		if(jslet.temp.focusing || !fldName) {
			return this;
		}
		var Z = this, ctrl,
			fldObj = Z.getField(fldName);
		if(!fldObj) {
			console.warn('Not found field: ' + fldName + ' in dataset: ' + Z.name());
			return this;
		}
		var dsDetail = fldObj.detailDataset();
		if(dsDetail) {
			fldName = dsDetail.getFirstFocusField();
			dsDetail.focusEditControl(fldName);
			return this;
		}
		for (var i = Z._linkedControls.length - 1; i &gt;= 0; i--) {
			ctrl = Z._linkedControls[i];
			if(!ctrl.field) {
				continue;
			}
			if (ctrl.field() == fldName) {
				//Avoid nesting call
				jslet.temp.focusing = true;
				try {
					ctrl.focus();
				} finally {
					jslet.temp.focusing = false;
					break;
				}
			}
		} //end for
		return this;
	},

<span id='jslet-data-Dataset-method-focusFirstErrorField'>	/**
</span>	 * Focus the first error field.
	 * 
	 * @return {this}
	 */
	focusFirstErrorField: function() {
		var fldName = jslet.data.FieldError.getFirstErrorField(this.getRecord());
		if(!fldName) {
			return this;
		}
		this.focusEditControl(fldName);
		return this;
	},
	
<span id='jslet-data-Dataset-method-refreshField'>	/**
</span>	 * Refresh whole field.
	 * 
	 * @param {String} fldName field name.
	 * 
	 * @return {this}
	 */
	refreshField: function(fldName) {
		this.refreshControl(jslet.data.RefreshEvent.updateColumnEvent(fldName));
		return this;
	},
	
<span id='jslet-data-Dataset-method-refreshLookupField'>	/**
</span>	 * Refresh lookup field.
	 * 
	 * @param {String} fldName field name.
	 * 
	 * @return {this}
	 */
	refreshLookupField: function(fldName) {
		var lookupEvt = jslet.data.RefreshEvent.lookupEvent(fldName);
		this.refreshControl(lookupEvt);
		return this;
	},
	
<span id='jslet-data-Dataset-method-refreshControl'>	/**
</span>	 * @private 
	 */
	refreshControl: function (updateEvt, clearFieldCache) {
		if (this._lockCount) {
			return;
		}

		if (!updateEvt) {
			updateEvt = jslet.data.RefreshEvent.updateAllEvent();
		}
		if(clearFieldCache) {
			jslet.data.FieldValueCache.removeAllCache(this);			
		}
		this._refreshInnerControl(updateEvt);
	},

<span id='jslet-data-Dataset-method-addLinkedControl'>	/**
</span>	 * @private 
	 */
	addLinkedControl: function (linkedControl) {
		if (linkedControl.isLabel) {
			this._linkedLabels.push(linkedControl);
		} else {
			this._linkedControls.push(linkedControl);
			var fldName = null;
			if(linkedControl.field) {
				fldName = linkedControl.field();
			}
			if(fldName &amp;&amp; linkedControl.canFocus()) {
				if(!this._canFocusFields) {
					this._canFocusFields = [];
				}
				this._canFocusFields.push(fldName);
			}
		}
	},

<span id='jslet-data-Dataset-method-removeLinkedControl'>	/**
</span>	 * @private 
	 */
	removeLinkedControl: function (linkedControl) {
		var arrCtrls = linkedControl.isLabel ? this._linkedLabels : this._linkedControls;
		if(!arrCtrls) {
			return;
		}
		var k = arrCtrls.indexOf(linkedControl);
		if (k &gt;= 0) {
			arrCtrls.splice(k, 1);
		}
		if(!linkedControl.isLabel &amp;&amp; linkedControl.field) {
			var fldName = linkedControl.field();
			if(fldName) {
				k = this._canFocusFields.indexOf(fldName);
				if(k &gt;= 0) {
					this._canFocusFields.splice(k, 1);
				}
			}
		}
	},

	refreshLookupHostDataset: function() {
		if(this._autoRefreshHostDataset) {
			jslet.data.datasetRelationManager.refreshLookupHostDataset(this._name);
		}
	},
	
	handleLookupDatasetChanged: function(fldName) {
		var Z = this;
		if(!Z._inContextRule) {
			jslet.data.FieldValueCache.clearAll(Z, fldName);
		}
		Z.refreshLookupField(fldName);
		//Don't use the following code, is will cause DBAutoComplete control issues.
		//this.refreshControl(jslet.data.RefreshEvent.updateColumnEvent(fldName));
	},

	innerExportTextArray: function(exportOption, csvFlag) {
		var Z = this;
		Z.confirm();
		if(Z.existDatasetError()) {
			console.warn(jsletlocale.Dataset.cannotConfirm);
		}

		var exportHeader = true,
			exportDisplayValue = true,
			onlySelected = false,
			onlyCurrent = false,
			recordRange = jslet.data.RecordRange.ALL,
			includeFields = null,
			excludeFields = null,
			escapeDate = true;
		
		if(exportOption &amp;&amp; jQuery.isPlainObject(exportOption)) {
			if(exportOption.exportHeader !== undefined) {
				exportHeader = exportOption.exportHeader? true: false;
			}
			if(exportOption.recordRange !== undefined) {
				recordRange = exportOption.recordRange;
				onlyCurrent = (recordRange === jslet.data.RecordRange.CURRENT);
				onlySelected = (recordRange === jslet.data.RecordRange.SELECTED);
			}
			if(exportOption.includeFields !== undefined) {
				includeFields = exportOption.includeFields;
				jslet.Checker.test('Dataset.exportCsv#exportOption.includeFields', includeFields).isArray();
			}
			if(exportOption.excludeFields !== undefined) {
				excludeFields = exportOption.excludeFields;
				jslet.Checker.test('Dataset.exportCsv#exportOption.excludeFields', excludeFields).isArray();
			}
		}
		var fldCnt, dateFields = null, fldObj, fldName;
		var exportFields = jslet.temp.exportFields &amp;&amp; jslet.temp.exportFields[Z.name()];
		if(!exportFields) {
			exportFields = [];
			fldCnt = Z._normalFields.length;
			for(var i = 0; i &lt; fldCnt; i++) {
				fldObj = Z._normalFields[i];
				fldName = fldObj.name();
				if(includeFields &amp;&amp; includeFields.length &gt; 0) {
					if(includeFields.indexOf(fldName) &lt; 0) {
						continue;
					}
				} else {
					if(!fldObj.visible()) {
						continue;
					}
				}
				if(excludeFields &amp;&amp; excludeFields.length &gt; 0) {
					if(excludeFields.indexOf(fldName) &gt;= 0) {
						continue;
					}
				} 
				if(csvFlag &amp;&amp; fldObj.getType() === jslet.data.DataType.DATE) {
					if(!dateFields) {
						dateFields = [];
					}
					dateFields.push(i);
				}
				exportFields.push(fldObj);
			}
			if(jslet.temp.exportFields) {
				jslet.temp.exportFields[Z.name()] = exportFields;
			}
		}
		
		var result = [], arrRec;
		
		fldCnt = exportFields.length;
		if (exportHeader) {
			arrRec = [];
			for(i = 0; i &lt; fldCnt; i++) {
				fldObj = exportFields[i];
				fldName = fldObj.label();
				arrRec.push(fldName);
			}
			result.push(arrRec);
		}

		
		var text, dataType;
		
		function exportOneRecord() {
			arrRec = [];
			for(var i = 0; i &lt; fldCnt; i++) {
				fldObj = exportFields[i];
				fldName = fldObj.name();
				//If Number field does not have lookup field, return field value, not field text. 
				//Example: 'amount' field
				dataType = fldObj.getType();
				if(dataType === jslet.data.DataType.DATASET) {
					arrRec.push(fldObj.detailDataset().innerExportTextArray({exportHeader: false}));
					continue;
				}
				if(dataType === jslet.data.DataType.NUMBER &amp;&amp; !fldObj.lookup()) {
					text = fldObj.getValue();
					if(text === null || text === undefined) {
						text = '';
					} else {
						text += '';
					}
				} else {
					text = Z.getFieldText(fldName);
					if(text === null || text === undefined) {
						text = '';
					}
					if(text &amp;&amp; dataType === jslet.data.DataType.STRING) {
						var replaceFn = text.replace;
						if(replaceFn) {
							text = jslet.removeHtmlTag(text);
						} else {
							text += '';
						}
					}
				}
				arrRec.push(text);
			}
			result.push(arrRec);
		}
		
		if(onlyCurrent) {
			exportOneRecord();
			return result;
		}
		var context = Z.startSilenceMove()
		try{
			Z.first();
			while(!Z.isEof()) {
				if (onlySelected &amp;&amp; !Z.selected()) {
					Z.next();
					continue;
				}
				exportOneRecord();
				Z.next();
			} // end while
			if(!csvFlag) {
				return result;
			} else {
				return [result, dateFields];
			}
		}finally{
			Z.endSilenceMove(context);
		}
	},

<span id='jslet-data-Dataset-method-exportTextArray'>	/**
</span>	 * Export dataset as text array like: [[123,'dd'], [[234], 'ee']].
	 * 
	 * @param {Object} exportOption Export options.
	 * @param {Boolean} exportOption.exportHeader True - export with field labels, false -otherwise.
	 * @param {Boolean} exportOption.onlySelected True - export selected records, false -otherwise.
	 * @param {Boolean} exportOption.onlyCurrent True - export current record, false -otherwise.
	 * @param {String[]} exportOption.includeFields Array of field names which to be exported.
	 * @param {String[]} exportOption.excludeFields Array of field names which not to be exported.
	 * 
	 * @return {String[][]} Text array. 
	 */
	exportTextArray: function(exportOption) {
		jslet.temp.exportFields = {};
		try {
			return this.innerExportTextArray(exportOption);
		} finally {
			delete jslet.temp.exportFields;
		}
	},
	
<span id='jslet-data-Dataset-method-exportCsv'>	/**
</span>	 * Export data with CSV format.
	 * 
	 * @param {Object} exportOption Export options.
	 * @param {Boolean} exportOption.exportHeader True - export with field labels, false -otherwise.
	 * @param {Boolean} exportOption.onlySelected True - export selected records, false -otherwise.
	 * @param {String[]} exportOption.includeFields Array of field names which to be exported.
	 * @param {String[]} exportOption.excludeFields Array of field names which not to be exported.
	 * 
	 * @return {String} Csv Text. 
	 */
	exportCsv: function(exportOption) {
		var textArr = this.innerExportTextArray(exportOption, true),
			dateFields = textArr[1];
		textArr = textArr[0];

		if(textArr.length === 0) {
			return '';
		}
		var escapeDate = true;
		if(exportOption.escapeDate !== undefined) {
			escapeDate = exportOption.escapeDate? true: false;
		}
		
		var	recArr = textArr[0],
			fldCnt = recArr.length,
			fldSeperator = ',', 
			surround='&quot;',
			text, isDate = false;
		
		for(var i = 0, recCnt = textArr.length; i &lt; recCnt; i++) {
			recArr = textArr[i];
			for(var j = 0; j &lt; fldCnt; j++) {
				text = recArr[j];
				if(text) {
					text = text.replace(/&quot;/g,'&quot;&quot;');
					var isStartZero = false;
					if(text.startsWith('0')) {
						isStartZero = true;
					} else {
						isDate = false;
						if(escapeDate &amp;&amp; dateFields &amp;&amp; i &gt; 0 &amp;&amp; dateFields.indexOf(j) &gt;= 0) {
							isDate = true;
						}
					}
					text = surround + text + surround;
					if(isStartZero || isDate) {
						text = '=' + text;
					}
				} else {
					text = '&quot;&quot;';
				}
				recArr[j] = text;
			}
			textArr[i] = recArr.join(fldSeperator);
		}
		return textArr.join('\n');
	},

<span id='jslet-data-Dataset-method-exportCsvFile'>	/**
</span>	 * Export data to CSV file.
	 *  
	 * @param {String} fileName Export file name.
	 * @param {Object} exportOption Export options.
	 * @param {Boolean} exportOption.exportHeader True - export with field labels, false -otherwise.
	 * @param {Boolean} exportOption.onlySelected True - export selected records, false -otherwise.
	 * @param {String[]} exportOption.includeFields Array of field names which to be exported.
	 * @param {String[]} exportOption.excludeFields Array of field names which not to be exported.
	 */
	exportCsvFile: function(fileName, exportOption) {
		jslet.Checker.test('Dataset.exportCsvFile#fileName', fileName).required().isString();
    	var str = this.exportCsv(exportOption);
        var a = document.createElement('a');
		
        var blob = new window.Blob([str], {'type': 'text\/csv'});
        a.href = window.URL.createObjectURL(blob);
        a.download = fileName;
        a.click();
    },
    
<span id='jslet-data-Dataset-method-filteredRecords'>	/** 
</span>	* Get filtered data records. 
	* 
	* @return {Object[]} Filtered data records.
	*/ 
	filteredRecords: function() { 
		var Z= this, 
			result = [], 
			oldRecno = Z.recnoSilence(); 
		Z.confirm();
		try { 
			for(var i = 0, len = Z.recordCount(); i &lt; len; i++) {
				Z.recnoSilence(i); 
				result.push(Z.getRecord()); 
			} 
		} finally { 
			Z.recnoSilence(oldRecno); 
		} 
		return result; 
	}, 

	filteredDataList: function() {
		return this.filteredRecords();
	},
	
<span id='jslet-data-Dataset-method-iterate'>	/** 
</span>	* Iterate the whole dataset, and run the specified callback function. Example: 
	* 
	*     @example
	*     dataset.iterate(function(){
	* 	    var fldValue = this.getFieldValue('xxx');
	* 	    this.setFieldValue('xxx', fldValue);
	*     }); 
	* 
	* @param {Function} callBackFn Call back function to iterate.
	* @param {Boolean} callBackFn.return True - break iterating, false - continue iterating.
	* @param {Integer} startRecno Start record number to iterate.
	* @param {Integer} endRecno End record number to iterate.
	* 
	* @return {this}
	*/ 
	iterate: function(callBackFn, startRecno, endRecno) { 
		jslet.Checker.test('Dataset.iterate#callBackFn', callBackFn).required().isFunction(); 
		var Z= this, 
			context = Z.startSilenceMove(); 
		try{
			startRecno = startRecno || 0;
			if(endRecno !== 0 &amp;&amp; !endRecno) {
				endRecno = Z.recordCount() - 1;
			}
			for(var k = startRecno; k &lt;= endRecno; k++) {
				Z.recno(k);
				if(callBackFn) { 
					if(callBackFn.call(Z)) {
						break;
					} 
				} 
			} 
		}finally{ 
			Z.endSilenceMove(context); 
		} 
		return this; 
	}, 
	
<span id='jslet-data-Dataset-method-records'>	/**
</span>	 * Set or get raw data records. Example:
	 * 
	 *     @example
	 *     var records = [{fld1: 123, fld2: 'test'}, {fld1: 100, fld2: 'world'}];
	 *     dsObj.records(records); //set data records.
	 *     var list = dsObj.records(); //return data records.
	 * 
	 * @param {Object[] | undefined} records Raw data records.
	 * 
	 * @return {this | Object[]}
	 */
	records: function (records) {
		var Z = this;
		if (records === undefined) {
			if(Z._masterField) {
				return Z.masterDataset().getFieldValue(Z._masterField);
			}
			return Z._records;
		}
		if(Z._isEnum &amp;&amp; records &amp;&amp; !jslet.isArray(records)) {
			var arrRecords = [];
			if(jslet.isString(records)) {
				var enumStr = jslet.trim(records);
				var recs = enumStr.split(','), recstr, rec;
				for (var i = 0, cnt = recs.length; i &lt; cnt; i++) {
					recstr = jslet.trim(recs[i]);
					rec = recstr.split(':');
			
					arrRecords[arrRecords.length] = {
						'code' : jslet.trim(rec[0]),
						'name' : jslet.trim(rec[1])
					};
				}
			} else {
				for(var key in records) {
					arrRecords[arrRecords.length] = {code: key, name: records[key]};
				}
			}
			Z._records = arrRecords;
			Z._initialize();
			return this;
		}
		jslet.Checker.test('Dataset.records', records).isArray();
		if(Z._masterField) {
			if(records === null) {
				records = [];
			}
			Z.masterDataset().setFieldValue(Z._masterField, records);
		} else {
			Z._records = records;
		}
		Z._initialize();
		var fields = Z._detailDatasetFields;
		if(fields) {
			var fldObj, dsDetail;
			for(var i = 0, len = fields.length; i &lt; len; i++) {
				fldObj = fields[i];
				dsDetail = fldObj.detailDataset();
				if(dsDetail) {
					dsDetail.confirm();
					dsDetail._initialize();
				}
			}
		}
		Z.calcContextRule();
		return this;
	},
	
	dataList: function(dataList) {
		return this.records(dataList);
	},
	
	_initialize: function(isDetailDs) {
		var Z = this;
		if(!isDetailDs) { //Master dataset
			jslet.data.FieldValueCache.removeAllCache(Z);
			jslet.data.FieldError.clearDatasetError(Z);
			Z._changeLog.clear();
		}
		Z.status(jslet.data.DataSetStatus.BROWSE);
		Z._recno = -1;
		Z.disableControls();
		try {
			Z._sortByFields();
			Z.filter(null);
			if(Z.filtered() || Z.fixedFilter()) {
				Z._doFilterChanged();			
			} else {
				Z.calcAggregatedValue();
			}
			Z.first();
		} finally {
			Z.enableControls();
		}
		Z.refreshLookupHostDataset();
	},
	
<span id='jslet-data-Dataset-method-exportTextList'>	/**
</span>	 * Return dataset data with field text, field text is formatted or calculated field value.
	 * You can use them to do your special processing like: use them in jquery template.
	 * 
	 * @param {String[]} includeFields Include fields to exports.
	 * @param {String[]} excludeFields Exclude fields to exports.
	 * 
	 * @return {String[][]}
	 */
	exportTextList: function(includeFields, excludeFields) {
		var Z = this;
		Z.confirm();
		
		var	oldRecno = Z.recno(), 
			result = [],
			fldCnt, arrFldObj,
			fldObj, fldName, textValue, textRec;
		if(includeFields || includeFields) {
			arrFldObj = [];
			for(var k = 0; k &lt; fldCnt; k++) {
				fldObj = Z._normalFields[k];
				fldName = fldObj.name();
				if(includeFields &amp;&amp; includeFields.indexOf(fldName) &gt;= 0) {
					arrFldObj.push(fldObj);
				}
				if(!includeFields &amp;&amp; excludeFields &amp;&amp; excludeFields.indexOf(fldName) &lt; 0) {
					arrFldObj.push(fldObj);
				}
			}
		} else {
			arrFldObj = Z._normalFields;
		}
		fldCnt = arrFldObj.length;
		try {
			for (var i = 0, cnt = Z.recordCount(); i &lt; cnt; i++) {
				Z.recnoSilence(i);
				textRec = {};
				for(var j = 0; j &lt; fldCnt; j++) {
					fldObj = arrFldObj[j];
					fldName = fldObj.name();
					if(fldObj.getType() === jslet.data.DataType.DATASET) {
						textValue = fldObj.detailDataset().exportTextList();
					} else {
						textValue = Z.getFieldText(fldName);
					}
					textRec[fldName] = textValue;
				}
				result.push(textRec);
			}
			return result;
		} finally {
			this.recnoSilence(oldRecno);
		}
	},
	
<span id='jslet-data-Dataset-method-importTextList'>	/**
</span>	 * Import data from a string value array. Example:
	 * 
	 *     @example
	 * 	   var textList = [{id: '1', name: 'Tom', department: 'QA'}, {id: '2', name: 'Jerry', department: 'Admin'}];
	 * 	   dataset.importTextList(textList);
	 * 
	 * @param {Object[]} textList A string array.
	 * @param {Integer} start (optional) The start position to import.
	 * @param {Integer} end (optional) The end position to import.
	 */
	importTextList: function(textList, start, end) {
		var Z = this;
		jslet.Checker.test('importTextList#textList', textList).isArray();
		if(!textList || textList.length === 0) {
			return;
		}
		if(!start) {
			start = 0;
		}
		if(!end &amp;&amp; end !== 0) {
			end = textList.length - 1;
		}
		Z.disableControls();
		Z.clearFollowedValues();
		var oldValueFollowEnabled = Z.valueFollowEnabled();
		Z.valueFollowEnabled(false);
		var oldReadOnly = Z.readOnly();
		try {
			var rec, fldObj, fldName, fldText, 
				fldCnt = Z._normalFields.length,
				cacheFieldMap = {}, cacheField, 
				cacheValue, value, errObj,
				oldRecno = Z.recno();
			Z.readOnly(false);
			for(var i = start; i &lt;= end; i++) {
				rec = textList[i];
				Z.appendRecord();
				for(var j = 0; j &lt; fldCnt; j++) {
					fldObj = Z._normalFields[j];
					fldName = fldObj.name();
					fldText = rec[fldName];
					if(fldText === undefined || fldText === '' || fldText === null) {
						continue;
					}
					if(fldObj.lookup()) {
						cacheField = cacheFieldMap[fldName];
						if(cacheField) {
							cacheValue = cacheField[fldText];
						} else {
							cacheField = {};
							cacheFieldMap[fldName] = cacheField;
							cacheValue = null;
						}
						if(cacheValue) {
							value = cacheValue.value;
							errObj = cacheValue.error;
							Z.setFieldValue(fldName, value);
							if(errObj) {
								Z.setFieldError(fldName, errObj.message, null, errObj.inputText);
							}
						} else {
							Z.setFieldText(fldName, fldText);
							value = Z.getFieldValue(fldName);
							errObj = Z.getFieldError(fldName);
							cacheField[fldText] = {value: value, error: errObj};
						}
						continue;
					}
					if(fldObj.getType() === jslet.data.DataType.DATASET) {
						if(fldText.length === 0) { //&quot;fldText&quot; must be an array.
							continue;
						}
						fldObj.detailDataset().importTextList(fldText);
					} else {
						Z.setFieldText(fldName, fldText);
					}
				}
				Z.confirm();
			}
		} finally {
			Z._sortByFields();
			Z.readOnly(oldReadOnly);
			Z.valueFollowEnabled(oldValueFollowEnabled);
			Z.recno(oldRecno + 1);
			Z.enableControls();
		}
	},
	
<span id='jslet-data-Dataset-method-exportSnapshot'>	/**
</span>	 * Export dataset snapshot. Dataset snapshot can be used for making a backup when inputing a lot of data. 
	 * 
	 * @return {Object} Dataset snapshot.
	 */
	exportSnapshot: function() {
		
		function getDetailSetting(masterDs, details) {
			var detail;
			var detailFields = masterDs._detailDatasetFields;
			if(!detailFields) {
				return;
			}
			var dtlFldObj, dsDetail;
			for(var i = 0, len = detailFields.length; i &lt; len; i++) {
				dtlFldObj = detailFields[i];
				dsDetail = dtlFldObj.detailDataset();
				if(dsDetail) {
					detail = {name: dsDetail.name(), recno: dsDetail.recno(), status: dsDetail.status()};
					indexFields = dsDetail.indexFields();
					if(indexFields) {
						dsDetail.indexFields = indexFields;
					}
					filter = dsDetail.filter();
					if(filter) {
						dsDetail.filter = filter;
						dsDetail.filtered = dsDetail.filtered();
					}
					details.push(detail);
					
					getDetailSetting(dsDetail, details);
				}
			}
		}
		
		var Z = this;
		if(Z.records() === 0) {
			return null;
		}
		if(Z.masterDataset()) {
			throw new Error('Can not call this method on detail dataset! Call it on &quot;' + Z.masterDataset().name() + '&quot;!');
		}
		var	mainDs = {name: Z.name(), recno: Z.recno(), status: Z.status(), records: Z.records(), changedRecords: Z._changeLog._changedRecords};
		var indexFields = Z.indexFields();
		if(indexFields) {
			mainDs.indexFields = indexFields;
		}
		var filter = Z.filter();
		if(filter) {
			mainDs.filter = filter;
			mainDs.filtered = Z.filtered();
		}
		var result = {master: mainDs};
		var details = [];
		getDetailSetting(Z, details);
		result.details = details;
		
		return result;
	},
	
<span id='jslet-data-Dataset-method-importSnapshot'>	/**
</span>	 * Import a dataset snapshot.
	 * 
	 * @param {Object} snapshot Dataset snapshot.
	 */
	importSnapshot: function(snapshot) {
		jslet.Checker.test('Dataset.importSnapshot#snapshot', snapshot).required().isPlanObject();
		var master = snapshot.master;
		jslet.Checker.test('Dataset.importSnapshot#snapshot.master', master).required().isPlanObject();
		var Z = this,
			dsName = master.name;
		if(Z.masterDataset()) {
			throw new Error('Can not call this method on detail dataset! Call it on &quot;' + Z.masterDataset().name() + '&quot;!');
		}
		if(dsName != Z._name) {
			//Snapshot name: [{0}] does not match the current dataset name: [{1}], cannot import snapshot!
			throw new Error(jslet.formatMessage(jsletlocale.Dataset.cannotImportSnapshot, [dsName, Z._name]));
		}
		Z._records = master.records || null;
		Z._changeLog._changedRecords = master.changedRecords;
		if(master.indexFields !== undefined) {
			Z.indexFields(master.indexFields);
		}
		if(master.filter !== undefined) {
			Z.filter(master.filter);
			Z.filtered(master.filtered);
		}
		if(master.recno &gt;= 0) {
			Z._silence++;
			try {
				Z.recno(master.recno);
				if(master.status) {
					Z.status(master.status);
				}
			} finally {
				Z._silence--;
			}
		}
		Z.calcAggregatedValue();
		Z.refreshControl();
		var details = snapshot.details;
		if(!details || details.length === 0) {
			return;
		}
		var detail, dsDetail;
		for(var i = 0, len = details.length; i &lt; len; i++) {
			detail = details[i];
			dsDetail = jslet.data.getDataset(detail.name);
			if(dsDetail) {
				if(detail.indexFields !== undefined) {
					dsDetail.indexFields(detail.indexFields);
				}
				if(detail.filter !== undefined) {
					dsDetail.filter(detail.filter);
					dsDetail.filtered(detail.filtered);
				}
				if(detail.recno &gt;= 0) {
					dsDetail._silence++;
					try {
						dsDetail.recno(detail.recno);
						if(detail.status) {
							dsDetail.status(detail.status);
						}
					} finally {
						dsDetail._silence--;
					}
				}
				dsDetail.refreshControl();
			}
		}
	},
	
<span id='jslet-data-Dataset-method-createField'>	/**
</span>	 * Create field object. Example:
	 * 
	 *     @example
	 *     var fldObj = dsObj.createField({name:'field1', dataType:'N', label: 'field1 label'});
	 * 
	 * @param {Object} fieldConfig A json object which property names are same as jslet.data.Field. Example: {name: 'xx', dataType: 'N', ...}
	 * @param {jslet.data.Field} parent (optional) Parent field object.
	 * 
	 * @return {jslet.data.Field}
	 */
	createField: function (fieldConfig, parentFldObj, batchMode) {
		jslet.Checker.test('Dataset.createField#fieldConfig', fieldConfig).required().isObject();
		var Z = this;
		var dtype = fieldConfig.type || fieldConfig.dataType;
		
		if(dtype === jslet.data.DataType.EXTEND) {
			Z._createExtendField(fieldConfig, parentFldObj);
		} else {
			var fldObj = new jslet.data.Field(Z, fieldConfig, parentFldObj);
			Z.addField(fldObj, batchMode);
		}
		return fldObj;
	},
	
	_createExtendField: function(fldCfg, parentFldObj) {
		jslet.Checker.test('createExtendField#extendFields', fldCfg.extendFields).required().isArray();
		var Z = this;
		var asChild = fldCfg.asChild;
		if(asChild) {
			var pFldObj = parentFldObj;
			parentFldObj = new jslet.data.Field(Z, fldCfg, parentFldObj);
			if(!pFldObj) {
				Z.addField(parentFldObj);
			}
		}
		var extFldCfg = {}, 
			extFldCfgs = fldCfg.extendFields,
			onCreatingExtendField = fldCfg.onCreatingExtendField,
			fldObjs = [], fldObj, firstSumFldCfg, 
			totalExpr = '', 
			hostFldName = fldCfg.name, 
			hasSum = false;
		
		for(var i = 0, len = extFldCfgs.length; i &lt; len; i++) {
			extFldCfg = extFldCfgs[i];
			if(onCreatingExtendField) {
				onCreatingExtendField(extFldCfg);
			}
			fldObj = new jslet.data.Field(Z, extFldCfg, parentFldObj);
			if(extFldCfg.needSum) {
				totalExpr += '+['+fldObj.name() + ']';
				if(!hasSum) {
					firstSumFldCfg = extFldCfg;
				}
				hasSum = true;
			}
			fldObj.extendHostName(hostFldName);
			fldObjs.push(fldObj);
		}
		if(hasSum) {
			extFldCfg = firstSumFldCfg;
			extFldCfg.name = fldCfg.name + '_sum';
			extFldCfg.label = jslet.trim((asChild? '' : (fldCfg.label || fldCfg.name)) + jsletlocale.Dataset.totalLabel);
			extFldCfg.formula = totalExpr.substring(1);
			fldObj = new jslet.data.Field(Z, extFldCfg, parentFldObj);
			fldObjs.push(fldObj);
		}
		if(!parentFldObj) {
			Z.addFields(fldObjs);
		}
		return fldObjs;
	},
	
	createFields: function(fieldConfigs) {
		if(!fieldConfigs) {
			return;
		}
		jslet.Checker.test('Dataset.createFields#fieldConfigs', fieldConfigs).isArray();
		var fldObj;
		for(var i = 0, len = fieldConfigs.length; i &lt; len; i++) {
			this.createField(fieldConfigs[i], null, true);
		}
		this.refreshDisplayOrder();
		this.refreshAggregatedFields();
	},

	destroy: function () {
		var Z = this;
		Z._masterDataset = null;
		Z._masterField = null;
		Z._fields = null;
		Z._linkedLabels = null;
		Z._linkedControls = null;
		Z._innerFilter = null;
		Z._innerFindCondition = null;
		Z._sortingFields = null;
		Z._innerFormularFields = null;
		Z._aggregatedFields = null;
		
		jslet.data.dataModule[Z._name] = null;
		delete jslet.data.dataModule[Z._name];
		jslet.data.datasetRelationManager.removeDataset(Z._name);		
	}
	
};
// end Dataset

<span id='jslet-data-method-createEnumDataset'>/**
</span> * Create Enum Dataset. This method is use to create the simple dataset.&lt;br /&gt;
 * The created dataset has two fixed fields: 'code', 'name'. Example:
 * 
 *     @example
 *     var dsGender = jslet.data.createEnumDataset('gender', 'F:Female,M:Male');
 *     dsGender.getFieldValue('code');//return 'F'
 *     dsGender.getFieldValue('name');//return 'Female'
 *     dsGender.next();
 *     dsGender.getFieldValue('code');//return 'M'
 *     dsGender.getFieldValue('name');//return 'Male'
 * 
 * @member jslet.data
 * @param {String} dsName Dataset name;  
 * @param {String} enumStr A string which stores enumeration data, its format must be:[code]: [name], [code]: [name].
 * @return {jslet.data.Dataset}
 */
jslet.data.createEnumDataset = function(dsName, enumStrOrObj) {
	return new jslet.data.Dataset({name: dsName, isEnum: true, records: enumStrOrObj});
};

<span id='jslet-data-method-createDynamicDataset'>/**
</span> * Create dataset with dataset configuration which is stored in other place, like DB, IndexedDB.&lt;br /&gt;
 * It will fire global event: {@link jslet.global.dataset#onDatasetCreating}, you can listen this event, load dataset configuration and create it.&lt;br /&gt;
 * This method will not return dataset object. You can call {@link jslet.data#getDataset} to get the dataset object. 
 * 
 * @fires onDatasetCreating 
 * @member jslet.data
 * @param {String} datasetName Dataset's name;
 * @param {Object} creatingOption Creating option, pattern:
 * {maxCreatingLevel: x, includeFields: ['fieldName1','fieldName2',...], excludeFields: ['fieldName8',...], onlyLookupFields: true|false}
 * @param {Integer} creatingOption.maxCreatingLevel Specified the max creating level when creating dataset nested(host dataset -&gt; lookup dataset -&gt; lookup dataset-&gt; ...). 
 * @param {String[]} creatingOption.includeFields Only create dataset with the specified field names.
 * @param {String[]} creatingOption.excludeFields Create dataset without the specified field names.
 * @param {Boolean} creatingOption.onlyLookupFields If onlyLookupFields is true, it will create dataset with fields which specified by the following dataset's properties: keyField, codeField, nameField, parentField and enabledField;
 * @param {jslet.data.DatasetType} creatingOption.datasetType The optional values are:  jslet.data.DatasetType.NORMAL, jslet.data.DatasetType.LOOKUP, jslet.data.DatasetType.DETAIL;
 * @param {String} creatingOption.realDatasetName Dataset creator uses &quot;realDatasetName&quot; to load dataset records.
 */
jslet.data.createDynamicDataset = function(dsName, creatingOption, hostDsName) {
	jslet.Checker.test('createDynamicDataset#dsName', dsName).required().isString();
	var dsObj = jslet.data.getDataset(dsName);
	if(dsObj) {
		return dsObj;
	}
	if(creatingOption &amp;&amp; creatingOption.maxCreatingLevel) {
		jslet.data.defaultDatasetCreatingManager.setMaxCreateLevel(dsName, maxCreatingLevel);
	}
	var dsType = creatingOption.datasetType;
	var isLookup = dsType &amp;&amp; dsType === jslet.data.DatasetType.LOOKUP;
	jslet.data.defaultDatasetCreatingManager.startCreateDataset(dsName, hostDsName, isLookup);
	if(jslet.global.dataset.onDatasetCreating) {
		jslet.global.dataset.onDatasetCreating(dsName, creatingOption);
	}
};

<span id='jslet-data-method-createDataset'>/**
</span> * Create dataset with field configurations. Example:
 * 
 *     @example
 *     var fldCfg = [{
 *       name: 'deptid',
 *       type: 'S',
 *       length: 10,
 *       label: 'ID'
 *     }, {
 *       name: 'name',
 *       type: 'S',
 *       length: 20,
 *       label: 'Dept. Name'
 *     }];
 *     var dsCfg = {keyField: 'deptid', codeField: 'deptid', nameField: 'name'};
 *     var dsDepartment = jslet.data.createDataset('department', fldCfg, dsCfg);
 * 
 * @member jslet.data
 * @param {String} datasetName Dataset name.
 * @param {Object[]} fieldConfigs A list of field configuration. See {@link jslet.data.Field} properties.
 * @param {Object} datasetProps Dataset properties, like: {keyField: '', codeField: '', ...}, see dataset properties.
 * @param {Integer} maxCreatingLevel Specified the max creating level when creating dataset nested(host dataset -&gt; lookup dataset -&gt; lookup dataset-&gt; ...). 
 * @return {jslet.data.Dataset}
 */
jslet.data.createDataset = function(dsName, fieldConfig, dsCfg, maxCreatingLevel) {
	jslet.Checker.test('createDataset#dsName', dsName).required().isString();
	jslet.Checker.test('createDataset#fieldConfig', fieldConfig).required().isArray();
	jslet.Checker.test('Dataset.createDataset#datasetCfg', dsCfg).isPlanObject();
	if(maxCreatingLevel) {
		jslet.data.defaultDatasetCreatingManager.setMaxCreateLevel(dsName, maxCreatingLevel);
	}
	var dsObj = new jslet.data.Dataset(jQuery.extend({name: dsName, fields: fieldConfig}, dsCfg));
	jslet.data.defaultDatasetCreatingManager.endCreateDataset(dsName);
	if(dsObj.isFireGlobalEvent()) {
		var globalHandler = jslet.data.globalDataHandler.datasetCreated();
		if(globalHandler) {
			globalHandler(dsObj);
		}
	}
	return dsObj;
};

jslet.data.ChangeLog = function(dataset) {
	this._dataset = dataset;
	this._changedRecords = null;
};

jslet.data.ChangeLog.prototype = {
	changedRecords: function(changedRecords) {
		if(changedRecords === undefined) {
			return this._getChangedRecords();
		}
		this._changedRecords = changedRecords;
	},
	
	log: function(recObj) {
		if(!this._dataset.logChanges()) {
			return;
		}
		if(!recObj) {
			recObj = this._dataset.getRecord();
		}
		var recInfo = jslet.data.getRecInfo(recObj);
		if(!recInfo.status) {
			return;
		}
		var chgRecords = this._getChangedRecords();
		if(chgRecords.indexOf(recObj) &lt; 0) {
			chgRecords.push(recObj);
		}
	},
	
	unlog: function(recObj) {
		if(!this._dataset.logChanges()) {
			return;
		}
		if(!recObj) {
			recObj = this._dataset.getRecord();
		}
		var chgRecords = this._getChangedRecords();
		var k = chgRecords.indexOf(recObj);
		if(k &gt;= 0) {
			chgRecords.splice(k, 1);
		}
	},
	
	clear: function() {
		this._changedRecords = null;
	},
	
	_getChangedRecords: function() {
		var dsObj = this._dataset;
		var chgRecords,
		  	masterDsObj = dsObj.masterDataset(),
		  	masterFldName = dsObj.masterField();
		if(masterDsObj &amp;&amp; masterFldName) {
			var masterRecInfo = jslet.data.getRecInfo(masterDsObj.getRecord());
			if(!masterRecInfo.detailLog) {
				masterRecInfo.detailLog = {};
			}
			chgRecords = masterRecInfo.detailLog[masterFldName];
			if(!chgRecords) {
				chgRecords = [];
				masterRecInfo.detailLog[masterFldName] = chgRecords;
			}
		} else {
			if(!this._changedRecords) {
				this._changedRecords = [];
			}
			chgRecords = this._changedRecords;
		}
		return chgRecords;
	}
	
};

jslet.data.DataTransformer = function(dataset) {
	this._dataset = dataset;
};

jslet.data.DataTransformer.prototype = {
		
	hasChangedData: function() {
		var chgRecList = this._dataset._changeLog.changedRecords();
		if(!chgRecList || chgRecList.length === 0) {
			return false;
		}
		return true;
	},
	
	getSubmittingChanged: function(range, detailRange) {
		if(!range || range === jslet.data.RecordRange.ALL) {
			range = jslet.data.RecordRange.CHANGED;
		}
		var chgRecList = this._getRecords(this._dataset, range);
		if(range !== jslet.data.RecordRange.CHANGED) {
			var newChgList = [], rec;
			var dsObj = this._dataset;
			for(var i = 0, len = chgRecList.length; i &lt; len; i++) {
				rec = chgRecList[i];
				if(dsObj.recordChanged(rec)) {
					newChgList.push(rec);
				}
			}
			chgRecList = newChgList;
		}
		var result = this._convert(this._dataset, chgRecList, detailRange);
		return result;
	},
	
	getSubmittingSelected: function(range, detailRange) {
		if(!range &amp;&amp; range !== jslet.data.RecordRange.ALL) {
			range = jslet.data.RecordRange.SELECTED;
		}
		var chgRecList = this._getRecords(this._dataset, range);
		var result = this._convert(this._dataset, chgRecList, detailRange);
		return result;
	},
	
	_getRecords: function(dsObj, range) {
		var result = null;
		switch(range) {
		case jslet.data.RecordRange.ALL:
			result = dsObj.records();
			break;
		case jslet.data.RecordRange.SELECTED:
			result = dsObj.selectedRecords();
			break;
		case jslet.data.RecordRange.CURRENT:
			result = [dsObj.getRecord()];
			break;
		case jslet.data.RecordRange.CHANGED:
			result =  dsObj._changeLog.changedRecords();
			break;
		}
		return result;
	},
	
	_convertRecord: function(dsObj, chgRec, detailRange, recInfo, recClazz) {
		var fldObj, newRec = {}, detailLog;
		for(var fldName in chgRec) {
			if(fldName === '_jl_') {
				continue;
			}
			fldObj = dsObj.getField(fldName);
			if(!fldObj || fldObj.getType() !== jslet.data.DataType.DATASET) {
				newRec[fldName] = chgRec[fldName];
				continue;
			}
			detailLog = recInfo.detailLog;
			var dsDetail = fldObj.detailDataset(),
				selStateFld = dsDetail.selectField() || jslet.global.selectStateField,
				dtlRange = detailRange;
			if(jslet.isObject(detailRange)) {
				dtlRange = detailRange[dsDetail.name()];
			}
			var allSubList = [], i, len,
				dtlRecs = chgRec[fldName], dtlRec;
			if(dtlRange === jslet.data.RecordRange.ALL) { //add deleted record
				if(dtlRecs) {
					for(i = 0, len = dtlRecs.length; i &lt; len; i++) {
						dtlRec = dtlRecs[i];
						allSubList.push(dtlRec);
					}
				}
				detailLog = detailLog? detailLog[fldName]: null;
				if(detailLog) {
					for(i = 0, len = detailLog.length; i &lt; len; i++) {
						var subChgRec = detailLog[i]; 
						var subRecInfo = jslet.data.getRecInfo(subChgRec);
						if(subRecInfo &amp;&amp; subRecInfo.status === jslet.data.DataSetStatus.DELETE) {
							allSubList.push(subChgRec);
						}
					}
				}
			} else if(dtlRange === jslet.data.RecordRange.CHANGED) {
				allSubList = detailLog? detailLog[fldName]: null;
			} else if(dtlRange === jslet.data.RecordRange.SELECTED) {
				if(dtlRecs) {
					for(i = 0, len = dtlRecs.length; i &lt; len; i++) {
						dtlRec = dtlRecs[i];
						if(dtlRec[selStateFld]) {
							allSubList.push(dtlRec);
						}
					}
				}
			}
			allSubList = this._convert(dsDetail, allSubList);
			if(allSubList) {
				newRec[fldName] = allSubList;
			}
		}
		return newRec;
	},
	
	_convert: function(dsObj, chgRecList, detailRange) {
		if(!detailRange) {
			detailRange = jslet.data.RecordRange.ALL;
		}
		
		if(!chgRecList || chgRecList.length === 0) {
			return null;
		}
		var chgRec, recInfo, status, newRec,
			recClazz = dsObj._recordClass || jslet.global.defaultRecordClass,
			result = [],
			detailLog,
			selStateFld = dsObj.selectField() || jslet.global.selectStateField;
		for(var i = 0, len = chgRecList.length; i &lt; len; i++) {
			chgRec = chgRecList[i];
			recInfo = jslet.data.getRecInfo(chgRec);
			chgRec[jslet.global.changeStateField] = this._getStatusPrefix(recInfo.status, chgRec[selStateFld]) + Math.round(Math.random()*10000);
			var newRec = this._convertRecord(dsObj, chgRec, detailRange, recInfo, recClazz);
			result.push(newRec);
		}
		return result;
	},
	
	_getStatusPrefix: function(status, selected) {
		return  status === jslet.data.DataSetStatus.INSERT ? 'i' : 
			(status === jslet.data.DataSetStatus.UPDATE? 'u':
			 status === jslet.data.DataSetStatus.DELETE? 'd': (selected? 's': ''));
	},
			
	refreshSubmittedData: function(submittedData) {
		if(!submittedData || submittedData.length === 0) {
			return;
		}
		this._refreshDataset(this._dataset, submittedData);
	},
	
	_refreshDataset: function(dsObj, submittedData, isDetailDataset) {
		if(!submittedData || submittedData.length === 0) {
			return;
		}
		var masterFldObj = dsObj.getMasterFieldObject(),
			chgLogs = dsObj._changeLog.changedRecords(),
			newRec, oldRec, flag;
		for(var i = 0, len = submittedData.length; i &lt; len; i++) {
			newRec = submittedData[i];
			if(!newRec) {
				//'The return record exists null. Please check it.'
				console.warn(jsletlocale.Dataset.serverReturnNullRecord);
				continue;
			}
			this._refreshRecord(dsObj, newRec, chgLogs);
		}
	},
		
	_refreshRecord: function(dsObj, newRec, chgLogs) {
		var recState = newRec[jslet.global.changeStateField];
		if(!recState) {
			return;
		}
		var i, len;
		if(chgLogs &amp;&amp; recState.charAt(0) == 'd') {
			for(i = 0, len = chgLogs.length; i &lt; len; i++) {
				if(recState == chgLogs[i][jslet.global.changeStateField]) {
					chgLogs.splice(i, 1);
					break;
				}
			}
			return;
		}
		var oldRec, fldObj,
			records = dsObj.records() || [];
		for(i = records.length - 1; i &gt;= 0; i--) {
			oldRec = records[i];
			if(oldRec[jslet.global.changeStateField] != recState) {
				continue;
			}
			for(var fldName in newRec) {
				if(!fldName) {
					continue;
				}
				fldObj = dsObj.getField(fldName);
				if(fldObj &amp;&amp; fldObj.detailDataset()) {
					this._refreshDataset(fldObj.detailDataset(), newRec[fldName], true);
				} else {
					oldRec[fldName] = newRec[fldName];
				}
			} // end for fldName
			if(chgLogs) {
				for(i = 0, len = chgLogs.length; i &lt; len; i++) {
					if(recState == chgLogs[i][jslet.global.changeStateField]) {
						chgLogs.splice(i, 1);
						break;
					}
				}
			}
			oldRec[jslet.global.changeStateField] = null;
			var auditLog = oldRec[jslet.global.auditLogField];
			if(auditLog) {
				delete oldRec[jslet.global.auditLogField];
			}
			var recInfo = jslet.data.getRecInfo(oldRec);
			if(recInfo &amp;&amp; recInfo.status) {
				recInfo.status = 0;
			}
			jslet.data.FieldValueCache.removeCache(oldRec);
		} // end for i
	}
};
</pre>
</body>
</html>
